{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { useQuery } from '@tanstack/react-query';\nimport { useDataProvider } from './useDataProvider';\nimport { useEffect } from 'react';\nimport { useEvent } from '../util';\n/**\n * Call the dataProvider.getOne() method and return the resolved value\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isPending: true, isFetching: true, refetch }\n * - success: { data: [data from response], isPending: false, refetch }\n * - error: { error: [error from response], isPending: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param resource The resource name, e.g. 'posts'\n * @param {Params} params The getOne parameters { id, meta }, e.g. { id: 123 }\n * @param {Options} options Options object to pass to the react-query queryClient.\n *\n * @typedef Params\n * @prop id a resource identifier, e.g. 123\n *\n * @typedef Options\n * @prop enabled Flag to conditionally run the query. If it's false, the query will not run\n * @prop onSuccess Side effect function to be executed upon success, e.g. { onSuccess: { refresh: true } }\n * @prop onError Side effect function to be executed upon failure, e.g. { onError: error => notify(error.message) }\n *\n * @returns The current request state. Destructure as { data, error, isPending, refetch }.\n *\n * @example\n *\n * import { useGetOne, useRecordContext } from 'react-admin';\n *\n * const UserProfile = () => {\n *     const record = useRecordContext();\n *     const { data, isPending, error } = useGetOne('users', { id: record.id });\n *     if (isPending) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return <div>User {data.username}</div>;\n * };\n */\nexport var useGetOne = function (resource, _a, options) {\n  var id = _a.id,\n    meta = _a.meta;\n  if (options === void 0) {\n    options = {};\n  }\n  var dataProvider = useDataProvider();\n  var _b = options.onError,\n    onError = _b === void 0 ? noop : _b,\n    _c = options.onSuccess,\n    onSuccess = _c === void 0 ? noop : _c,\n    _d = options.onSettled,\n    onSettled = _d === void 0 ? noop : _d,\n    enabled = options.enabled,\n    queryOptions = __rest(options, [\"onError\", \"onSuccess\", \"onSettled\", \"enabled\"]);\n  var onSuccessEvent = useEvent(onSuccess);\n  var onErrorEvent = useEvent(onError);\n  var onSettledEvent = useEvent(onSettled);\n  var result = useQuery(__assign({\n    // Sometimes the id comes as a string (e.g. when read from the URL in a Show view).\n    // Sometimes the id comes as a number (e.g. when read from a Record in useGetList response).\n    // As the react-query cache is type-sensitive, we always stringify the identifier to get a match\n    queryKey: [resource, 'getOne', {\n      id: String(id),\n      meta: meta\n    }],\n    queryFn: function (queryParams) {\n      return id == null ? new Promise(function () {}) : dataProvider.getOne(resource, {\n        id: id,\n        meta: meta,\n        signal: dataProvider.supportAbortSignal === true ? queryParams.signal : undefined\n      }).then(function (_a) {\n        var data = _a.data;\n        return data;\n      });\n    },\n    enabled: enabled !== null && enabled !== void 0 ? enabled : id != null\n  }, queryOptions));\n  useEffect(function () {\n    if (result.data === undefined || result.error != null || result.isFetching) return;\n    onSuccessEvent(result.data);\n  }, [onSuccessEvent, result.data, result.error, result.isFetching]);\n  useEffect(function () {\n    if (result.error == null || result.isFetching) return;\n    onErrorEvent(result.error);\n  }, [onErrorEvent, result.error, result.isFetching]);\n  useEffect(function () {\n    if (result.status === 'pending' || result.isFetching) return;\n    onSettledEvent(result.data, result.error);\n  }, [onSettledEvent, result.data, result.error, result.status, result.isFetching]);\n  return result;\n};\nvar noop = function () {\n  return undefined;\n};","map":{"version":3,"names":["useQuery","useDataProvider","useEffect","useEvent","useGetOne","resource","_a","options","id","meta","dataProvider","_b","onError","noop","_c","onSuccess","_d","onSettled","enabled","queryOptions","__rest","onSuccessEvent","onErrorEvent","onSettledEvent","result","__assign","queryKey","String","queryFn","queryParams","Promise","getOne","signal","supportAbortSignal","undefined","then","data","error","isFetching","status"],"sources":["/home/diarietou/Bureau/afterSA/test/testfront/react-admin-test/node_modules/ra-core/src/dataProvider/useGetOne.ts"],"sourcesContent":["import { RaRecord, GetOneParams, GetOneResult } from '../types';\nimport {\n    useQuery,\n    UseQueryOptions,\n    UseQueryResult,\n} from '@tanstack/react-query';\nimport { useDataProvider } from './useDataProvider';\nimport { useEffect } from 'react';\nimport { useEvent } from '../util';\n\n/**\n * Call the dataProvider.getOne() method and return the resolved value\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isPending: true, isFetching: true, refetch }\n * - success: { data: [data from response], isPending: false, refetch }\n * - error: { error: [error from response], isPending: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param resource The resource name, e.g. 'posts'\n * @param {Params} params The getOne parameters { id, meta }, e.g. { id: 123 }\n * @param {Options} options Options object to pass to the react-query queryClient.\n *\n * @typedef Params\n * @prop id a resource identifier, e.g. 123\n *\n * @typedef Options\n * @prop enabled Flag to conditionally run the query. If it's false, the query will not run\n * @prop onSuccess Side effect function to be executed upon success, e.g. { onSuccess: { refresh: true } }\n * @prop onError Side effect function to be executed upon failure, e.g. { onError: error => notify(error.message) }\n *\n * @returns The current request state. Destructure as { data, error, isPending, refetch }.\n *\n * @example\n *\n * import { useGetOne, useRecordContext } from 'react-admin';\n *\n * const UserProfile = () => {\n *     const record = useRecordContext();\n *     const { data, isPending, error } = useGetOne('users', { id: record.id });\n *     if (isPending) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return <div>User {data.username}</div>;\n * };\n */\nexport const useGetOne = <RecordType extends RaRecord = any, ErrorType = Error>(\n    resource: string,\n    { id, meta }: Partial<GetOneParams<RecordType>>,\n    options: UseGetOneOptions<RecordType, ErrorType> = {}\n): UseGetOneHookValue<RecordType, ErrorType> => {\n    const dataProvider = useDataProvider();\n    const {\n        onError = noop,\n        onSuccess = noop,\n        onSettled = noop,\n        enabled,\n        ...queryOptions\n    } = options;\n    const onSuccessEvent = useEvent(onSuccess);\n    const onErrorEvent = useEvent(onError);\n    const onSettledEvent = useEvent(onSettled);\n\n    const result = useQuery<RecordType, ErrorType>({\n        // Sometimes the id comes as a string (e.g. when read from the URL in a Show view).\n        // Sometimes the id comes as a number (e.g. when read from a Record in useGetList response).\n        // As the react-query cache is type-sensitive, we always stringify the identifier to get a match\n        queryKey: [resource, 'getOne', { id: String(id), meta }],\n        queryFn: queryParams =>\n            id == null\n                ? new Promise(() => {})\n                : dataProvider\n                      .getOne<RecordType>(resource, {\n                          id,\n                          meta,\n                          signal:\n                              dataProvider.supportAbortSignal === true\n                                  ? queryParams.signal\n                                  : undefined,\n                      })\n                      .then(({ data }) => data),\n        enabled: enabled ?? id != null,\n        ...queryOptions,\n    });\n\n    useEffect(() => {\n        if (\n            result.data === undefined ||\n            result.error != null ||\n            result.isFetching\n        )\n            return;\n        onSuccessEvent(result.data);\n    }, [onSuccessEvent, result.data, result.error, result.isFetching]);\n\n    useEffect(() => {\n        if (result.error == null || result.isFetching) return;\n        onErrorEvent(result.error);\n    }, [onErrorEvent, result.error, result.isFetching]);\n\n    useEffect(() => {\n        if (result.status === 'pending' || result.isFetching) return;\n        onSettledEvent(result.data, result.error);\n    }, [\n        onSettledEvent,\n        result.data,\n        result.error,\n        result.status,\n        result.isFetching,\n    ]);\n\n    return result;\n};\n\nconst noop = () => undefined;\n\nexport type UseGetOneOptions<\n    RecordType extends RaRecord = any,\n    ErrorType = Error,\n> = Omit<\n    UseQueryOptions<GetOneResult<RecordType>['data'], ErrorType>,\n    'queryKey' | 'queryFn'\n> & {\n    onSuccess?: (data: GetOneResult<RecordType>['data']) => void;\n    onError?: (error: ErrorType) => void;\n    onSettled?: (\n        data?: GetOneResult<RecordType>['data'],\n        error?: ErrorType | null\n    ) => void;\n};\n\nexport type UseGetOneHookValue<\n    RecordType extends RaRecord = any,\n    ErrorType = Error,\n> = UseQueryResult<GetOneResult<RecordType>['data'], ErrorType>;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}