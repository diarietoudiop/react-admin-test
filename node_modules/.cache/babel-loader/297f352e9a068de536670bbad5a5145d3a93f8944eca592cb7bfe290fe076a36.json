{"ast":null,"code":"import { useState, useEffect } from 'react';\nimport { useResourceContext } from '../core/useResourceContext';\nimport { useRecordContext } from '../controller/record/useRecordContext';\nimport { useCanAccess } from '../auth';\nimport { useResourceDefinition } from '../core';\nimport { useCreatePath } from './useCreatePath';\n/**\n * Get a path for a record, based on the current resource and the link type.\n *\n * Accepted link types are 'edit', 'show', a route string, false, or a function returning one of these types.\n *\n * @example\n * // basic usage (leverages RecordContext, ResourceContext and ResourceDefinitionContext)\n * const EditLink = () => {\n *   const path = useGetPathForRecord();\n *   return path ? <Link to={path}>Edit</Link> : null;\n * };\n *\n * // controlled mode\n * const EditLink = ({ record, resource }) => {\n *    const path = useGetPathForRecord({ record, resource, link: 'edit' });\n *    return path ? <Link to={path}>Edit</Link> : null;\n * };\n *\n * // the link option can be a function\n * const EditLink = ({ record, resource }) => {\n *   const path = useGetPathForRecord({ record, resource, link: (record, resource) => record.canEdit ? 'edit' : false });\n *   return path ? <Link to={path}>Edit</Link> : null;\n * };\n *\n * // the link option can be a function returning a promise\n * const EditLink = ({ record, resource }) => {\n *   const path = useGetPathForRecord({ record, resource, link: async (record, resource) => {\n *     const canEdit = await canEditRecord(record, resource);\n *     return canEdit ? 'edit' : false;\n *   }});\n *   return path ? <Link to={path}>Edit</Link> : null;\n * };\n */\nexport var useGetPathForRecord = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var link = (options || {}).link;\n  var record = useRecordContext(options);\n  var resource = useResourceContext(options);\n  if (!resource) {\n    throw new Error('Cannot generate a link for a record without a resource. You must use useGetPathForRecord within a ResourceContextProvider, or pass a resource prop.');\n  }\n  var resourceDefinition = useResourceDefinition(options);\n  var createPath = useCreatePath();\n  var _a = useState(link && typeof link !== 'function' && record != null ? createPath({\n      resource: resource,\n      id: record.id,\n      type: link\n    }) : false),\n    path = _a[0],\n    setPath = _a[1];\n  // in preparation for the default value, does the user have access to the show and edit pages?\n  // (we can't run hooks conditionally, so we need to run them even though the link is specified)\n  var canAccessShow = useCanAccess({\n    action: 'show',\n    resource: resource,\n    record: record,\n    enabled: link == null && resourceDefinition.hasShow\n  }).canAccess;\n  var canAccessEdit = useCanAccess({\n    action: 'edit',\n    resource: resource,\n    record: record,\n    enabled: link == null && resourceDefinition.hasEdit\n  }).canAccess;\n  useEffect(function () {\n    if (!record) return;\n    if (link === false) {\n      setPath(false);\n      return;\n    }\n    // Handle the inferred link type case\n    if (link == null) {\n      // We must check whether the resource has an edit view because if there is no\n      // authProvider, canAccessShow will always be true\n      if (resourceDefinition.hasShow && canAccessShow) {\n        setPath(createPath({\n          resource: resource,\n          id: record.id,\n          type: 'show'\n        }));\n        return;\n      }\n      // We must check whether the resource has an edit view because if there is no\n      // authProvider, canAccessEdit will always be true\n      if (resourceDefinition.hasEdit && canAccessEdit) {\n        setPath(createPath({\n          resource: resource,\n          id: record.id,\n          type: 'edit'\n        }));\n        return;\n      }\n    }\n    // Handle the link function case\n    if (typeof link === 'function') {\n      var linkResult = link(record, resource);\n      if (linkResult instanceof Promise) {\n        linkResult.then(function (resolvedPath) {\n          return setPath(resolvedPath);\n        });\n        return;\n      }\n      setPath(linkResult ? createPath({\n        resource: resource,\n        id: record.id,\n        type: linkResult\n      }) : false);\n      return;\n    }\n    // handle string case\n    if (link) {\n      setPath(createPath({\n        resource: resource,\n        id: record.id,\n        type: link\n      }));\n    }\n  }, [createPath, canAccessShow, canAccessEdit, link, record, resource, resourceDefinition.hasEdit, resourceDefinition.hasShow]);\n  return path;\n};","map":{"version":3,"names":["useState","useEffect","useResourceContext","useRecordContext","useCanAccess","useResourceDefinition","useCreatePath","useGetPathForRecord","options","link","record","resource","Error","resourceDefinition","createPath","_a","id","type","path","setPath","canAccessShow","action","enabled","hasShow","canAccess","canAccessEdit","hasEdit","linkResult","Promise","then","resolvedPath"],"sources":["/home/diarietou/Bureau/afterSA/test/testfront/react-admin-test/node_modules/ra-core/src/routing/useGetPathForRecord.ts"],"sourcesContent":["import { useState, useEffect } from 'react';\nimport { useResourceContext } from '../core/useResourceContext';\nimport { useRecordContext } from '../controller/record/useRecordContext';\nimport type { RaRecord } from '../types';\nimport type { LinkToType } from './types';\nimport { useCanAccess } from '../auth';\nimport { useResourceDefinition } from '../core';\nimport { useCreatePath } from './useCreatePath';\n\n/**\n * Get a path for a record, based on the current resource and the link type.\n *\n * Accepted link types are 'edit', 'show', a route string, false, or a function returning one of these types.\n *\n * @example\n * // basic usage (leverages RecordContext, ResourceContext and ResourceDefinitionContext)\n * const EditLink = () => {\n *   const path = useGetPathForRecord();\n *   return path ? <Link to={path}>Edit</Link> : null;\n * };\n *\n * // controlled mode\n * const EditLink = ({ record, resource }) => {\n *    const path = useGetPathForRecord({ record, resource, link: 'edit' });\n *    return path ? <Link to={path}>Edit</Link> : null;\n * };\n *\n * // the link option can be a function\n * const EditLink = ({ record, resource }) => {\n *   const path = useGetPathForRecord({ record, resource, link: (record, resource) => record.canEdit ? 'edit' : false });\n *   return path ? <Link to={path}>Edit</Link> : null;\n * };\n *\n * // the link option can be a function returning a promise\n * const EditLink = ({ record, resource }) => {\n *   const path = useGetPathForRecord({ record, resource, link: async (record, resource) => {\n *     const canEdit = await canEditRecord(record, resource);\n *     return canEdit ? 'edit' : false;\n *   }});\n *   return path ? <Link to={path}>Edit</Link> : null;\n * };\n */\nexport const useGetPathForRecord = <RecordType extends RaRecord = RaRecord>(\n    options: UseGetPathForRecordOptions<RecordType> = {}\n): string | false | undefined => {\n    const { link } = options || {};\n    const record = useRecordContext(options);\n    const resource = useResourceContext(options);\n    if (!resource) {\n        throw new Error(\n            'Cannot generate a link for a record without a resource. You must use useGetPathForRecord within a ResourceContextProvider, or pass a resource prop.'\n        );\n    }\n    const resourceDefinition = useResourceDefinition(options);\n    const createPath = useCreatePath();\n    const [path, setPath] = useState<string | false>(\n        link && typeof link !== 'function' && record != null\n            ? createPath({\n                  resource,\n                  id: record.id,\n                  type: link,\n              })\n            : false\n    );\n\n    // in preparation for the default value, does the user have access to the show and edit pages?\n    // (we can't run hooks conditionally, so we need to run them even though the link is specified)\n    const { canAccess: canAccessShow } = useCanAccess({\n        action: 'show',\n        resource,\n        record,\n        enabled: link == null && resourceDefinition.hasShow,\n    });\n    const { canAccess: canAccessEdit } = useCanAccess({\n        action: 'edit',\n        resource,\n        record,\n        enabled: link == null && resourceDefinition.hasEdit,\n    });\n\n    useEffect(() => {\n        if (!record) return;\n\n        if (link === false) {\n            setPath(false);\n            return;\n        }\n\n        // Handle the inferred link type case\n        if (link == null) {\n            // We must check whether the resource has an edit view because if there is no\n            // authProvider, canAccessShow will always be true\n            if (resourceDefinition.hasShow && canAccessShow) {\n                setPath(\n                    createPath({\n                        resource,\n                        id: record.id,\n                        type: 'show',\n                    })\n                );\n                return;\n            }\n            // We must check whether the resource has an edit view because if there is no\n            // authProvider, canAccessEdit will always be true\n            if (resourceDefinition.hasEdit && canAccessEdit) {\n                setPath(\n                    createPath({\n                        resource,\n                        id: record.id,\n                        type: 'edit',\n                    })\n                );\n                return;\n            }\n        }\n\n        // Handle the link function case\n        if (typeof link === 'function') {\n            const linkResult = link(record, resource);\n            if (linkResult instanceof Promise) {\n                linkResult.then(resolvedPath => setPath(resolvedPath));\n                return;\n            }\n            setPath(\n                linkResult\n                    ? createPath({\n                          resource,\n                          id: record.id,\n                          type: linkResult,\n                      })\n                    : false\n            );\n            return;\n        }\n\n        // handle string case\n        if (link) {\n            setPath(\n                createPath({\n                    resource,\n                    id: record.id,\n                    type: link,\n                })\n            );\n        }\n    }, [\n        createPath,\n        canAccessShow,\n        canAccessEdit,\n        link,\n        record,\n        resource,\n        resourceDefinition.hasEdit,\n        resourceDefinition.hasShow,\n    ]);\n\n    return path;\n};\n\nexport interface UseGetPathForRecordOptions<\n    RecordType extends RaRecord = RaRecord,\n> {\n    resource?: string;\n    record?: RecordType;\n    link?: LinkToType<RecordType>;\n}\n\nexport type UseGetRouteForRecordOptions<\n    RecordType extends RaRecord = RaRecord,\n> = UseGetPathForRecordOptions<RecordType>;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}