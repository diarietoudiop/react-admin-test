{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport * as React from 'react';\nimport { isValidElement, useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport debounce from 'lodash/debounce';\nimport get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport clsx from 'clsx';\nimport { Autocomplete, Chip, TextField, createFilterOptions } from '@mui/material';\nimport { styled } from '@mui/material/styles';\nimport { FieldTitle, useChoicesContext, useInput, useSuggestions, useTimeout, useTranslate, warning, useGetRecordRepresentation, useEvent } from 'ra-core';\nimport { useSupportCreateSuggestion } from './useSupportCreateSuggestion';\nimport { InputHelperText } from './InputHelperText';\nimport { sanitizeInputRestProps } from './sanitizeInputRestProps';\nvar defaultFilterOptions = createFilterOptions();\n/**\n * An Input component for an autocomplete field, using an array of objects for the options\n *\n * Pass possible options as an array of objects in the 'choices' attribute.\n *\n * By default, the options are built from:\n *  - the 'id' property as the option value,\n *  - the 'name' property as the option text\n * @example\n * const choices = [\n *    { id: 'M', name: 'Male' },\n *    { id: 'F', name: 'Female' },\n * ];\n * <AutocompleteInput source=\"gender\" choices={choices} />\n *\n * You can also customize the properties to use for the option name and value,\n * thanks to the 'optionText' and 'optionValue' attributes.\n * @example\n * const choices = [\n *    { _id: 123, full_name: 'Leo Tolstoi', sex: 'M' },\n *    { _id: 456, full_name: 'Jane Austen', sex: 'F' },\n * ];\n * <AutocompleteInput source=\"author_id\" choices={choices} optionText=\"full_name\" optionValue=\"_id\" />\n *\n * `optionText` also accepts a function, so you can shape the option text at will:\n * @example\n * const choices = [\n *    { id: 123, first_name: 'Leo', last_name: 'Tolstoi' },\n *    { id: 456, first_name: 'Jane', last_name: 'Austen' },\n * ];\n * const optionRenderer = choice => `${choice.first_name} ${choice.last_name}`;\n * <AutocompleteInput source=\"author_id\" choices={choices} optionText={optionRenderer} />\n *\n * `optionText` also accepts a React Element, that can access\n * the related choice through the `useRecordContext` hook. You can use Field components there.\n * Note that you must also specify the `matchSuggestion` and `inputText` props\n * @example\n * const choices = [\n *    { id: 123, first_name: 'Leo', last_name: 'Tolstoi' },\n *    { id: 456, first_name: 'Jane', last_name: 'Austen' },\n * ];\n * const matchSuggestion = (filterValue, choice) => choice.first_name.match(filterValue) || choice.last_name.match(filterValue)\n * const inputText = (record) => `${record.fullName} (${record.language})`;\n *\n * const FullNameField = () => {\n *     const record = useRecordContext();\n *     return <span>{record.first_name} {record.last_name}</span>;\n * }\n * <AutocompleteInput source=\"author\" choices={choices} optionText={<FullNameField />} matchSuggestion={matchSuggestion} inputText={inputText} />\n *\n * The choices are translated by default, so you can use translation identifiers as choices:\n * @example\n * const choices = [\n *    { id: 'M', name: 'myroot.gender.male' },\n *    { id: 'F', name: 'myroot.gender.female' },\n * ];\n *\n * However, in some cases (e.g. inside a `<ReferenceInput>`), you may not want\n * the choice to be translated. In that case, set the `translateChoice` prop to false.\n * @example\n * <AutocompleteInput source=\"gender\" choices={choices} translateChoice={false}/>\n *\n * The object passed as `options` props is passed to the Material UI <TextField> component\n *\n * @example\n * <AutocompleteInput source=\"author_id\" options={{ color: 'secondary', InputLabelProps: { shrink: true } }} />\n */\nexport var AutocompleteInput = function (props) {\n  var choicesProp = props.choices,\n    className = props.className,\n    _a = props.clearOnBlur,\n    clearOnBlur = _a === void 0 ? true : _a,\n    _b = props.clearText,\n    clearText = _b === void 0 ? 'ra.action.clear_input_value' : _b,\n    _c = props.closeText,\n    closeText = _c === void 0 ? 'ra.action.close' : _c,\n    create = props.create,\n    createLabel = props.createLabel,\n    _d = props.createItemLabel,\n    createItemLabel = _d === void 0 ? 'ra.action.create_item' : _d,\n    createValue = props.createValue,\n    createHintValue = props.createHintValue,\n    _e = props.debounce,\n    debounceDelay = _e === void 0 ? 250 : _e,\n    defaultValue = props.defaultValue,\n    emptyText = props.emptyText,\n    _f = props.emptyValue,\n    emptyValue = _f === void 0 ? '' : _f,\n    fieldOverride = props.field,\n    format = props.format,\n    helperText = props.helperText,\n    idOverride = props.id,\n    inputText = props.inputText,\n    isFetchingProp = props.isFetching,\n    isLoadingProp = props.isLoading,\n    isPendingProp = props.isPending,\n    isRequiredOverride = props.isRequired,\n    label = props.label,\n    limitChoicesToValue = props.limitChoicesToValue,\n    matchSuggestion = props.matchSuggestion,\n    margin = props.margin,\n    fieldStateOverride = props.fieldState,\n    _g = props.filterToQuery,\n    filterToQueryProp = _g === void 0 ? DefaultFilterToQuery : _g,\n    formStateOverride = props.formState,\n    _h = props.multiple,\n    multiple = _h === void 0 ? false : _h,\n    noOptionsText = props.noOptionsText,\n    onBlur = props.onBlur,\n    onChange = props.onChange,\n    onCreate = props.onCreate,\n    _j = props.openText,\n    openText = _j === void 0 ? 'ra.action.open' : _j,\n    optionText = props.optionText,\n    optionValue = props.optionValue,\n    parse = props.parse,\n    resourceProp = props.resource,\n    shouldRenderSuggestions = props.shouldRenderSuggestions,\n    setFilter = props.setFilter,\n    size = props.size,\n    sourceProp = props.source,\n    _k = props.suggestionLimit,\n    suggestionLimit = _k === void 0 ? Infinity : _k,\n    TextFieldProps = props.TextFieldProps,\n    translateChoice = props.translateChoice,\n    validate = props.validate,\n    variant = props.variant,\n    onInputChange = props.onInputChange,\n    disabled = props.disabled,\n    readOnly = props.readOnly,\n    getOptionDisabledProp = props.getOptionDisabled,\n    rest = __rest(props, [\"choices\", \"className\", \"clearOnBlur\", \"clearText\", \"closeText\", \"create\", \"createLabel\", \"createItemLabel\", \"createValue\", \"createHintValue\", \"debounce\", \"defaultValue\", \"emptyText\", \"emptyValue\", \"field\", \"format\", \"helperText\", \"id\", \"inputText\", \"isFetching\", \"isLoading\", \"isPending\", \"isRequired\", \"label\", \"limitChoicesToValue\", \"matchSuggestion\", \"margin\", \"fieldState\", \"filterToQuery\", \"formState\", \"multiple\", \"noOptionsText\", \"onBlur\", \"onChange\", \"onCreate\", \"openText\", \"optionText\", \"optionValue\", \"parse\", \"resource\", \"shouldRenderSuggestions\", \"setFilter\", \"size\", \"source\", \"suggestionLimit\", \"TextFieldProps\", \"translateChoice\", \"validate\", \"variant\", \"onInputChange\", \"disabled\", \"readOnly\", \"getOptionDisabled\"]);\n  var filterToQuery = useEvent(filterToQueryProp);\n  var _l = useChoicesContext({\n      choices: choicesProp,\n      isFetching: isFetchingProp,\n      isLoading: isLoadingProp,\n      isPending: isPendingProp,\n      resource: resourceProp,\n      source: sourceProp\n    }),\n    allChoices = _l.allChoices,\n    isPending = _l.isPending,\n    fetchError = _l.error,\n    resource = _l.resource,\n    source = _l.source,\n    setFilters = _l.setFilters,\n    isFromReference = _l.isFromReference;\n  var translate = useTranslate();\n  var _m = useInput(__assign({\n      defaultValue: defaultValue,\n      id: idOverride,\n      field: fieldOverride,\n      fieldState: fieldStateOverride,\n      formState: formStateOverride,\n      isRequired: isRequiredOverride,\n      onBlur: onBlur,\n      onChange: onChange,\n      parse: parse,\n      format: format,\n      resource: resource,\n      source: source,\n      validate: validate,\n      disabled: disabled,\n      readOnly: readOnly\n    }, rest)),\n    id = _m.id,\n    field = _m.field,\n    isRequired = _m.isRequired,\n    _o = _m.fieldState,\n    error = _o.error,\n    invalid = _o.invalid;\n  var finalChoices = useMemo(function () {\n    var _a;\n    // eslint-disable-next-line eqeqeq\n    return emptyText == undefined || isRequired || multiple ? allChoices : [(_a = {}, _a[optionValue || 'id'] = emptyValue, _a[typeof optionText === 'string' ? optionText : 'name'] = translate(emptyText, {\n      _: emptyText\n    }), _a)].concat(allChoices || []);\n  }, [allChoices, emptyValue, emptyText, isRequired, multiple, optionText, optionValue, translate]);\n  var selectedChoice = useSelectedChoice(field.value, {\n    choices: finalChoices,\n    // @ts-ignore\n    multiple: multiple,\n    optionValue: optionValue\n  });\n  useEffect(function () {\n    // eslint-disable-next-line eqeqeq\n    if (emptyValue == null) {\n      throw new Error(\"emptyValue being set to null or undefined is not supported. Use parse to turn the empty string into null.\");\n    }\n  }, [emptyValue]);\n  useEffect(function () {\n    // eslint-disable-next-line eqeqeq\n    if (isValidElement(optionText) && emptyText != undefined) {\n      throw new Error(\"optionText of type React element is not supported when setting emptyText\");\n    }\n    // eslint-disable-next-line eqeqeq\n    if (isValidElement(optionText) && inputText == undefined) {\n      throw new Error(\"\\nIf you provided a React element for the optionText prop, you must also provide the inputText prop (used for the text input)\");\n    }\n    if (isValidElement(optionText) && !isFromReference &&\n    // eslint-disable-next-line eqeqeq\n    matchSuggestion == undefined) {\n      throw new Error(\"\\nIf you provided a React element for the optionText prop, you must also provide the matchSuggestion prop (used to match the user input with a choice)\");\n    }\n  }, [optionText, inputText, matchSuggestion, emptyText, isFromReference]);\n  useEffect(function () {\n    warning(/* eslint-disable eqeqeq */\n    shouldRenderSuggestions != undefined && noOptionsText == undefined, \"When providing a shouldRenderSuggestions function, we recommend you also provide the noOptionsText prop and set it to a text explaining users why no options are displayed. It supports translation keys.\");\n    /* eslint-enable eqeqeq */\n  }, [shouldRenderSuggestions, noOptionsText]);\n  var getRecordRepresentation = useGetRecordRepresentation(resource);\n  var _p = useSuggestions({\n      choices: finalChoices,\n      limitChoicesToValue: limitChoicesToValue,\n      matchSuggestion: matchSuggestion,\n      optionText: optionText !== null && optionText !== void 0 ? optionText : isFromReference ? getRecordRepresentation : undefined,\n      optionValue: optionValue,\n      selectedItem: selectedChoice,\n      suggestionLimit: suggestionLimit,\n      translateChoice: translateChoice !== null && translateChoice !== void 0 ? translateChoice : !isFromReference\n    }),\n    getChoiceText = _p.getChoiceText,\n    getChoiceValue = _p.getChoiceValue,\n    getSuggestions = _p.getSuggestions;\n  var _q = useState(''),\n    filterValue = _q[0],\n    setFilterValue = _q[1];\n  var handleChange = function (newValue) {\n    var _a, _b;\n    if (multiple) {\n      if (Array.isArray(newValue)) {\n        field.onChange(newValue.map(getChoiceValue), newValue);\n      } else {\n        field.onChange(__spreadArray(__spreadArray([], (_a = field.value) !== null && _a !== void 0 ? _a : [], true), [getChoiceValue(newValue)], false), newValue);\n      }\n    } else {\n      field.onChange((_b = getChoiceValue(newValue)) !== null && _b !== void 0 ? _b : emptyValue, newValue);\n    }\n  };\n  // eslint-disable-next-line\n  var debouncedSetFilter = useCallback(debounce(function (filter) {\n    if (setFilter) {\n      return setFilter(filter);\n    }\n    if (choicesProp) {\n      return;\n    }\n    setFilters(filterToQuery(filter));\n  }, debounceDelay), [debounceDelay, setFilters, setFilter]);\n  // We must reset the filter every time the value changes to ensure we\n  // display at least some choices even if the input has a value.\n  // Otherwise, it would only display the currently selected one and the user\n  // would have to first clear the input before seeing any other choices\n  var currentValue = useRef(field.value);\n  useEffect(function () {\n    if (!isEqual(currentValue.current, field.value)) {\n      currentValue.current = field.value;\n      debouncedSetFilter('');\n    }\n  }, [field.value]); // eslint-disable-line\n  var _r = useSupportCreateSuggestion({\n      create: create,\n      createLabel: createLabel,\n      createItemLabel: createItemLabel,\n      createValue: createValue,\n      createHintValue: createHintValue,\n      handleChange: handleChange,\n      filter: filterValue,\n      onCreate: onCreate,\n      optionText: optionText\n    }),\n    getCreateItem = _r.getCreateItem,\n    handleChangeWithCreateSupport = _r.handleChange,\n    createElement = _r.createElement,\n    createId = _r.createId,\n    getOptionDisabledWithCreateSupport = _r.getOptionDisabled;\n  var getOptionDisabled = useCallback(function (option) {\n    return getOptionDisabledWithCreateSupport(option) || getOptionDisabledProp && getOptionDisabledProp(option);\n  }, [getOptionDisabledProp, getOptionDisabledWithCreateSupport]);\n  var getOptionLabel = useCallback(function (option, isListItem) {\n    if (isListItem === void 0) {\n      isListItem = false;\n    }\n    // eslint-disable-next-line eqeqeq\n    if (option == undefined) {\n      return '';\n    }\n    // Value selected with enter, right from the input\n    if (typeof option === 'string') {\n      return option;\n    }\n    if ((option === null || option === void 0 ? void 0 : option.id) === createId) {\n      return get(option, typeof optionText === 'string' ? optionText : 'name');\n    }\n    if (!isListItem && option[optionValue || 'id'] === emptyValue) {\n      return get(option, typeof optionText === 'string' ? optionText : 'name');\n    }\n    if (!isListItem && inputText !== undefined) {\n      return inputText(option);\n    }\n    return getChoiceText(option);\n  }, [getChoiceText, inputText, createId, optionText, optionValue, emptyValue]);\n  var finalOnBlur = useCallback(function () {\n    if (clearOnBlur && !multiple) {\n      var optionLabel = getOptionLabel(selectedChoice);\n      if (!isEqual(optionLabel, filterValue)) {\n        setFilterValue(optionLabel);\n        debouncedSetFilter('');\n      }\n    }\n    field.onBlur();\n  }, [clearOnBlur, field, getOptionLabel, selectedChoice, filterValue, debouncedSetFilter, multiple]);\n  useEffect(function () {\n    if (!multiple) {\n      var optionLabel = getOptionLabel(selectedChoice);\n      if (typeof optionLabel === 'string') {\n        setFilterValue(optionLabel);\n      } else {\n        throw new Error('When optionText returns a React element, you must also provide the inputText prop');\n      }\n    }\n  }, [getOptionLabel, multiple, selectedChoice]);\n  var handleInputChange = function (event, newInputValue, reason) {\n    if ((event === null || event === void 0 ? void 0 : event.type) === 'change' || !doesQueryMatchSelection(newInputValue)) {\n      var createOptionLabel = translate(createItemLabel, {\n        item: filterValue,\n        _: createItemLabel\n      });\n      var isCreate = newInputValue === createOptionLabel;\n      var valueToSet = isCreate ? filterValue : newInputValue;\n      setFilterValue(valueToSet);\n      debouncedSetFilter(newInputValue);\n    }\n    if (reason === 'clear') {\n      setFilterValue('');\n      debouncedSetFilter('');\n    }\n    onInputChange === null || onInputChange === void 0 ? void 0 : onInputChange(event, newInputValue, reason);\n  };\n  var doesQueryMatchSelection = useCallback(function (filter) {\n    var selectedItemTexts;\n    if (multiple) {\n      selectedItemTexts = selectedChoice.map(function (item) {\n        return getOptionLabel(item);\n      });\n    } else {\n      selectedItemTexts = [getOptionLabel(selectedChoice)];\n    }\n    return selectedItemTexts.includes(filter);\n  }, [getOptionLabel, multiple, selectedChoice]);\n  var doesQueryMatchSuggestion = useCallback(function (filter) {\n    var hasOption = !!finalChoices ? finalChoices.some(function (choice) {\n      return getOptionLabel(choice) === filter;\n    }) : false;\n    return doesQueryMatchSelection(filter) || hasOption;\n  }, [finalChoices, getOptionLabel, doesQueryMatchSelection]);\n  var filterOptions = function (options, params) {\n    var filteredOptions = isFromReference ||\n    // When used inside a reference, AutocompleteInput shouldn't do the filtering as it's done by the reference input\n    matchSuggestion ||\n    // When using element as optionText (and matchSuggestion), options are filtered by getSuggestions, so they shouldn't be filtered here\n    limitChoicesToValue // When limiting choices to values (why? it's legacy!), options are also filtered by getSuggestions, so they shouldn't be filtered here\n    ? options : defaultFilterOptions(options, params); // Otherwise, we let Material UI's Autocomplete do the filtering\n    // add create option if necessary\n    var inputValue = params.inputValue;\n    if (onCreate || create) {\n      if (inputValue === '' && filterValue === '' && createLabel) {\n        // create option with createLabel\n        filteredOptions = filteredOptions.concat(getCreateItem(''));\n      } else if (inputValue && filterValue && !doesQueryMatchSuggestion(filterValue)) {\n        filteredOptions = filteredOptions.concat(\n        // create option with createItemLabel\n        getCreateItem(inputValue));\n      }\n    }\n    return filteredOptions;\n  };\n  var handleAutocompleteChange = useCallback(function (event, newValue, reason) {\n    // This prevents auto-submitting a form inside a dialog passed to the `create` prop\n    event.preventDefault();\n    if (reason === 'createOption') {\n      // When users press the enter key after typing a new value, we can handle it as if they clicked on the create option\n      handleChangeWithCreateSupport(getCreateItem(newValue));\n      return;\n    }\n    handleChangeWithCreateSupport(newValue != null ? newValue : emptyValue);\n  }, [emptyValue, getCreateItem, handleChangeWithCreateSupport]);\n  var oneSecondHasPassed = useTimeout(1000, filterValue);\n  var suggestions = useMemo(function () {\n    if (!isFromReference && (matchSuggestion || limitChoicesToValue)) {\n      return getSuggestions(filterValue);\n    }\n    return (finalChoices === null || finalChoices === void 0 ? void 0 : finalChoices.slice(0, suggestionLimit)) || [];\n  }, [finalChoices, filterValue, getSuggestions, limitChoicesToValue, matchSuggestion, suggestionLimit, isFromReference]);\n  var isOptionEqualToValue = function (option, value) {\n    return String(getChoiceValue(option)) === String(getChoiceValue(value));\n  };\n  var renderHelperText = !!fetchError || helperText !== false || invalid;\n  return React.createElement(React.Fragment, null, React.createElement(StyledAutocomplete, __assign({\n    className: clsx('ra-input', \"ra-input-\".concat(source), className),\n    clearText: translate(clearText, {\n      _: clearText\n    }),\n    closeText: translate(closeText, {\n      _: closeText\n    }),\n    openOnFocus: true,\n    openText: translate(openText, {\n      _: openText\n    }),\n    id: id,\n    isOptionEqualToValue: isOptionEqualToValue,\n    filterSelectedOptions: true,\n    disabled: disabled || readOnly,\n    renderInput: function (params) {\n      var mergedTextFieldProps = __assign(__assign({\n        readOnly: readOnly\n      }, params.InputProps), TextFieldProps === null || TextFieldProps === void 0 ? void 0 : TextFieldProps.InputProps);\n      return React.createElement(TextField, __assign({\n        name: field.name,\n        label: React.createElement(FieldTitle, {\n          label: label,\n          source: source,\n          resource: resourceProp,\n          isRequired: isRequired\n        }),\n        error: !!fetchError || invalid,\n        helperText: renderHelperText ? React.createElement(InputHelperText, {\n          error: (error === null || error === void 0 ? void 0 : error.message) || (fetchError === null || fetchError === void 0 ? void 0 : fetchError.message),\n          helperText: helperText\n        }) : null,\n        margin: margin,\n        variant: variant,\n        className: AutocompleteInputClasses.textField\n      }, params, TextFieldProps, {\n        InputProps: mergedTextFieldProps,\n        size: size\n      }));\n    },\n    multiple: multiple,\n    renderTags: function (value, getTagProps) {\n      return value.map(function (option, index) {\n        // We have to extract the key because react 19 does not allow to spread the key prop\n        var _a = getTagProps({\n            index: index\n          }),\n          key = _a.key,\n          tagProps = __rest(_a, [\"key\"]);\n        return React.createElement(Chip, __assign({\n          label: isValidElement(optionText) ? inputText ? inputText(option) : '' : getChoiceText(option),\n          size: \"small\",\n          key: key\n        }, tagProps));\n      });\n    },\n    noOptionsText: typeof noOptionsText === 'string' ? translate(noOptionsText, {\n      _: noOptionsText\n    }) : noOptionsText,\n    selectOnFocus: true,\n    clearOnBlur: clearOnBlur\n  }, sanitizeInputRestProps(rest), {\n    freeSolo: !!create || !!onCreate,\n    handleHomeEndKeys: !!create || !!onCreate,\n    filterOptions: filterOptions,\n    options: shouldRenderSuggestions == undefined ||\n    // eslint-disable-line eqeqeq\n    shouldRenderSuggestions(filterValue) ? suggestions : [],\n    getOptionLabel: getOptionLabel,\n    inputValue: filterValue,\n    loading: isPending && (!finalChoices || finalChoices.length === 0) && oneSecondHasPassed,\n    value: selectedChoice,\n    onChange: handleAutocompleteChange,\n    onBlur: finalOnBlur,\n    onInputChange: handleInputChange,\n    renderOption: function (props, record) {\n      // We have to extract the key because react 19 does not allow to spread the key prop\n      var ignoredKey = props.key,\n        rest = __rest(props, [\"key\"]);\n      // We don't use MUI key which is generated from the option label because we may have options with the same label but with different values\n      var key = getChoiceValue(record);\n      var optionLabel = getOptionLabel(record, true);\n      return React.createElement(\"li\", __assign({\n        key: key\n      }, rest), optionLabel === '' ? ' ' : optionLabel);\n    },\n    getOptionDisabled: getOptionDisabled\n  })), createElement);\n};\nvar PREFIX = 'RaAutocompleteInput';\nexport var AutocompleteInputClasses = {\n  textField: \"\".concat(PREFIX, \"-textField\")\n};\nvar StyledAutocomplete = styled(Autocomplete, {\n  name: PREFIX,\n  overridesResolver: function (props, styles) {\n    return styles.root;\n  }\n})(function (_a) {\n  var _b;\n  var theme = _a.theme;\n  return _b = {}, _b[\"& .\".concat(AutocompleteInputClasses.textField)] = {\n    minWidth: theme.spacing(20)\n  }, _b;\n});\n/**\n * Returns the selected choice (or choices if multiple) by matching the input value with the choices.\n */\nvar useSelectedChoice = function (value, _a) {\n  var choices = _a.choices,\n    multiple = _a.multiple,\n    optionValue = _a.optionValue;\n  var selectedChoiceRef = useRef(getSelectedItems(choices, value, optionValue, multiple));\n  var _b = useState(function () {\n      return getSelectedItems(choices, value, optionValue, multiple);\n    }),\n    selectedChoice = _b[0],\n    setSelectedChoice = _b[1];\n  // As the selected choices are objects, we want to ensure we pass the same\n  // reference to the Autocomplete as it would reset its filter value otherwise.\n  useEffect(function () {\n    var newSelectedItems = getSelectedItems(choices, value, optionValue, multiple);\n    if (!areSelectedItemsEqual(selectedChoiceRef.current, newSelectedItems, optionValue, multiple)) {\n      selectedChoiceRef.current = newSelectedItems;\n      setSelectedChoice(newSelectedItems);\n    }\n  }, [choices, value, multiple, optionValue]);\n  return selectedChoice || null;\n};\nvar getSelectedItems = function (choices, value, optionValue, multiple) {\n  if (choices === void 0) {\n    choices = [];\n  }\n  if (optionValue === void 0) {\n    optionValue = 'id';\n  }\n  if (multiple) {\n    return (Array.isArray(value !== null && value !== void 0 ? value : []) ? value : [value]).map(function (item) {\n      return choices.find(function (choice) {\n        return String(item) === String(get(choice, optionValue));\n      });\n    }).filter(function (item) {\n      return !!item;\n    });\n  }\n  return choices.find(function (choice) {\n    return String(get(choice, optionValue)) === String(value);\n  }) || '';\n};\nvar areSelectedItemsEqual = function (selectedChoice, newSelectedChoice, optionValue, multiple) {\n  var _a, _b;\n  if (optionValue === void 0) {\n    optionValue = 'id';\n  }\n  if (multiple) {\n    var selectedChoiceArray = (_a = selectedChoice) !== null && _a !== void 0 ? _a : [];\n    var newSelectedChoiceArray_1 = (_b = newSelectedChoice) !== null && _b !== void 0 ? _b : [];\n    if (selectedChoiceArray.length !== newSelectedChoiceArray_1.length) {\n      return false;\n    }\n    var equalityArray = selectedChoiceArray.map(function (choice) {\n      return newSelectedChoiceArray_1.some(function (newChoice) {\n        return get(newChoice, optionValue) === get(choice, optionValue);\n      });\n    });\n    return !equalityArray.some(function (item) {\n      return item === false;\n    });\n  }\n  return get(selectedChoice, optionValue) === get(newSelectedChoice, optionValue);\n};\nvar DefaultFilterToQuery = function (searchText) {\n  return {\n    q: searchText\n  };\n};","map":{"version":3,"names":["React","isValidElement","useCallback","useEffect","useMemo","useRef","useState","debounce","get","isEqual","clsx","Autocomplete","Chip","TextField","createFilterOptions","styled","FieldTitle","useChoicesContext","useInput","useSuggestions","useTimeout","useTranslate","warning","useGetRecordRepresentation","useEvent","useSupportCreateSuggestion","InputHelperText","sanitizeInputRestProps","defaultFilterOptions","AutocompleteInput","props","choicesProp","choices","className","_a","clearOnBlur","_b","clearText","_c","closeText","create","createLabel","_d","createItemLabel","createValue","createHintValue","_e","debounceDelay","defaultValue","emptyText","_f","emptyValue","fieldOverride","field","format","helperText","idOverride","id","inputText","isFetchingProp","isFetching","isLoadingProp","isLoading","isPendingProp","isPending","isRequiredOverride","isRequired","label","limitChoicesToValue","matchSuggestion","margin","fieldStateOverride","fieldState","_g","filterToQuery","filterToQueryProp","DefaultFilterToQuery","formStateOverride","formState","_h","multiple","noOptionsText","onBlur","onChange","onCreate","_j","openText","optionText","optionValue","parse","resourceProp","resource","shouldRenderSuggestions","setFilter","size","sourceProp","source","_k","suggestionLimit","Infinity","TextFieldProps","translateChoice","validate","variant","onInputChange","disabled","readOnly","getOptionDisabledProp","getOptionDisabled","rest","__rest","_l","allChoices","fetchError","error","setFilters","isFromReference","translate","_m","__assign","_o","invalid","finalChoices","undefined","_","concat","selectedChoice","useSelectedChoice","value","Error","getRecordRepresentation","_p","selectedItem","getChoiceText","getChoiceValue","getSuggestions","_q","filterValue","setFilterValue","handleChange","newValue","Array","isArray","map","__spreadArray","debouncedSetFilter","filter","currentValue","current","_r","getCreateItem","handleChangeWithCreateSupport","createElement","createId","getOptionDisabledWithCreateSupport","option","getOptionLabel","isListItem","finalOnBlur","optionLabel","handleInputChange","event","newInputValue","reason","type","doesQueryMatchSelection","createOptionLabel","item","isCreate","valueToSet","selectedItemTexts","includes","doesQueryMatchSuggestion","hasOption","some","choice","filterOptions","options","params","filteredOptions","inputValue","handleAutocompleteChange","preventDefault","oneSecondHasPassed","suggestions","slice","isOptionEqualToValue","String","renderHelperText","Fragment","StyledAutocomplete","openOnFocus","filterSelectedOptions","renderInput","mergedTextFieldProps","InputProps","name","message","AutocompleteInputClasses","textField","renderTags","getTagProps","index","key","tagProps","selectOnFocus","freeSolo","handleHomeEndKeys","loading","length","renderOption","record","ignoredKey","PREFIX","overridesResolver","styles","root","theme","minWidth","spacing","selectedChoiceRef","getSelectedItems","setSelectedChoice","newSelectedItems","areSelectedItemsEqual","find","newSelectedChoice","selectedChoiceArray","newSelectedChoiceArray_1","equalityArray","newChoice","searchText","q"],"sources":["/home/diarietou/Bureau/afterSA/test/testfront/react-admin-test/node_modules/ra-ui-materialui/src/input/AutocompleteInput.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n    isValidElement,\n    useCallback,\n    useEffect,\n    useMemo,\n    useRef,\n    useState,\n    ReactNode,\n} from 'react';\nimport debounce from 'lodash/debounce';\nimport get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport clsx from 'clsx';\nimport {\n    Autocomplete,\n    AutocompleteChangeReason,\n    AutocompleteProps,\n    Chip,\n    TextField,\n    TextFieldProps,\n    createFilterOptions,\n} from '@mui/material';\nimport { styled } from '@mui/material/styles';\nimport {\n    ChoicesProps,\n    FieldTitle,\n    RaRecord,\n    useChoicesContext,\n    useInput,\n    useSuggestions,\n    UseSuggestionsOptions,\n    useTimeout,\n    useTranslate,\n    warning,\n    useGetRecordRepresentation,\n    useEvent,\n} from 'ra-core';\nimport {\n    SupportCreateSuggestionOptions,\n    useSupportCreateSuggestion,\n} from './useSupportCreateSuggestion';\nimport { CommonInputProps } from './CommonInputProps';\nimport { InputHelperText } from './InputHelperText';\nimport { sanitizeInputRestProps } from './sanitizeInputRestProps';\n\nconst defaultFilterOptions = createFilterOptions();\n\n/**\n * An Input component for an autocomplete field, using an array of objects for the options\n *\n * Pass possible options as an array of objects in the 'choices' attribute.\n *\n * By default, the options are built from:\n *  - the 'id' property as the option value,\n *  - the 'name' property as the option text\n * @example\n * const choices = [\n *    { id: 'M', name: 'Male' },\n *    { id: 'F', name: 'Female' },\n * ];\n * <AutocompleteInput source=\"gender\" choices={choices} />\n *\n * You can also customize the properties to use for the option name and value,\n * thanks to the 'optionText' and 'optionValue' attributes.\n * @example\n * const choices = [\n *    { _id: 123, full_name: 'Leo Tolstoi', sex: 'M' },\n *    { _id: 456, full_name: 'Jane Austen', sex: 'F' },\n * ];\n * <AutocompleteInput source=\"author_id\" choices={choices} optionText=\"full_name\" optionValue=\"_id\" />\n *\n * `optionText` also accepts a function, so you can shape the option text at will:\n * @example\n * const choices = [\n *    { id: 123, first_name: 'Leo', last_name: 'Tolstoi' },\n *    { id: 456, first_name: 'Jane', last_name: 'Austen' },\n * ];\n * const optionRenderer = choice => `${choice.first_name} ${choice.last_name}`;\n * <AutocompleteInput source=\"author_id\" choices={choices} optionText={optionRenderer} />\n *\n * `optionText` also accepts a React Element, that can access\n * the related choice through the `useRecordContext` hook. You can use Field components there.\n * Note that you must also specify the `matchSuggestion` and `inputText` props\n * @example\n * const choices = [\n *    { id: 123, first_name: 'Leo', last_name: 'Tolstoi' },\n *    { id: 456, first_name: 'Jane', last_name: 'Austen' },\n * ];\n * const matchSuggestion = (filterValue, choice) => choice.first_name.match(filterValue) || choice.last_name.match(filterValue)\n * const inputText = (record) => `${record.fullName} (${record.language})`;\n *\n * const FullNameField = () => {\n *     const record = useRecordContext();\n *     return <span>{record.first_name} {record.last_name}</span>;\n * }\n * <AutocompleteInput source=\"author\" choices={choices} optionText={<FullNameField />} matchSuggestion={matchSuggestion} inputText={inputText} />\n *\n * The choices are translated by default, so you can use translation identifiers as choices:\n * @example\n * const choices = [\n *    { id: 'M', name: 'myroot.gender.male' },\n *    { id: 'F', name: 'myroot.gender.female' },\n * ];\n *\n * However, in some cases (e.g. inside a `<ReferenceInput>`), you may not want\n * the choice to be translated. In that case, set the `translateChoice` prop to false.\n * @example\n * <AutocompleteInput source=\"gender\" choices={choices} translateChoice={false}/>\n *\n * The object passed as `options` props is passed to the Material UI <TextField> component\n *\n * @example\n * <AutocompleteInput source=\"author_id\" options={{ color: 'secondary', InputLabelProps: { shrink: true } }} />\n */\nexport const AutocompleteInput = <\n    OptionType extends RaRecord = RaRecord,\n    Multiple extends boolean | undefined = false,\n    DisableClearable extends boolean | undefined = boolean | undefined,\n    SupportCreate extends boolean | undefined = false,\n>(\n    props: AutocompleteInputProps<\n        OptionType,\n        Multiple,\n        DisableClearable,\n        SupportCreate\n    >\n) => {\n    const {\n        choices: choicesProp,\n        className,\n        clearOnBlur = true,\n        clearText = 'ra.action.clear_input_value',\n        closeText = 'ra.action.close',\n        create,\n        createLabel,\n        createItemLabel = 'ra.action.create_item',\n        createValue,\n        createHintValue,\n        debounce: debounceDelay = 250,\n        defaultValue,\n        emptyText,\n        emptyValue = '',\n        field: fieldOverride,\n        format,\n        helperText,\n        id: idOverride,\n        inputText,\n        isFetching: isFetchingProp,\n        isLoading: isLoadingProp,\n        isPending: isPendingProp,\n        isRequired: isRequiredOverride,\n        label,\n        limitChoicesToValue,\n        matchSuggestion,\n        margin,\n        fieldState: fieldStateOverride,\n        filterToQuery: filterToQueryProp = DefaultFilterToQuery,\n        formState: formStateOverride,\n        multiple = false,\n        noOptionsText,\n        onBlur,\n        onChange,\n        onCreate,\n        openText = 'ra.action.open',\n        optionText,\n        optionValue,\n        parse,\n        resource: resourceProp,\n        shouldRenderSuggestions,\n        setFilter,\n        size,\n        source: sourceProp,\n        suggestionLimit = Infinity,\n        TextFieldProps,\n        translateChoice,\n        validate,\n        variant,\n        onInputChange,\n        disabled,\n        readOnly,\n        getOptionDisabled: getOptionDisabledProp,\n        ...rest\n    } = props;\n\n    const filterToQuery = useEvent(filterToQueryProp);\n\n    const {\n        allChoices,\n        isPending,\n        error: fetchError,\n        resource,\n        source,\n        setFilters,\n        isFromReference,\n    } = useChoicesContext({\n        choices: choicesProp,\n        isFetching: isFetchingProp,\n        isLoading: isLoadingProp,\n        isPending: isPendingProp,\n        resource: resourceProp,\n        source: sourceProp,\n    });\n\n    const translate = useTranslate();\n\n    const {\n        id,\n        field,\n        isRequired,\n        fieldState: { error, invalid },\n    } = useInput({\n        defaultValue,\n        id: idOverride,\n        field: fieldOverride,\n        fieldState: fieldStateOverride,\n        formState: formStateOverride,\n        isRequired: isRequiredOverride,\n        onBlur,\n        onChange,\n        parse,\n        format,\n        resource,\n        source,\n        validate,\n        disabled,\n        readOnly,\n        ...rest,\n    });\n\n    const finalChoices = useMemo(\n        () =>\n            // eslint-disable-next-line eqeqeq\n            emptyText == undefined || isRequired || multiple\n                ? allChoices\n                : [\n                      {\n                          [optionValue || 'id']: emptyValue,\n                          [typeof optionText === 'string'\n                              ? optionText\n                              : 'name']: translate(emptyText, {\n                              _: emptyText,\n                          }),\n                      },\n                  ].concat(allChoices || []),\n        [\n            allChoices,\n            emptyValue,\n            emptyText,\n            isRequired,\n            multiple,\n            optionText,\n            optionValue,\n            translate,\n        ]\n    );\n\n    const selectedChoice = useSelectedChoice<\n        OptionType,\n        Multiple,\n        DisableClearable,\n        SupportCreate\n    >(field.value, {\n        choices: finalChoices,\n        // @ts-ignore\n        multiple,\n        optionValue,\n    });\n\n    useEffect(() => {\n        // eslint-disable-next-line eqeqeq\n        if (emptyValue == null) {\n            throw new Error(\n                `emptyValue being set to null or undefined is not supported. Use parse to turn the empty string into null.`\n            );\n        }\n    }, [emptyValue]);\n\n    useEffect(() => {\n        // eslint-disable-next-line eqeqeq\n        if (isValidElement(optionText) && emptyText != undefined) {\n            throw new Error(\n                `optionText of type React element is not supported when setting emptyText`\n            );\n        }\n        // eslint-disable-next-line eqeqeq\n        if (isValidElement(optionText) && inputText == undefined) {\n            throw new Error(`\nIf you provided a React element for the optionText prop, you must also provide the inputText prop (used for the text input)`);\n        }\n        if (\n            isValidElement(optionText) &&\n            !isFromReference &&\n            // eslint-disable-next-line eqeqeq\n            matchSuggestion == undefined\n        ) {\n            throw new Error(`\nIf you provided a React element for the optionText prop, you must also provide the matchSuggestion prop (used to match the user input with a choice)`);\n        }\n    }, [optionText, inputText, matchSuggestion, emptyText, isFromReference]);\n\n    useEffect(() => {\n        warning(\n            /* eslint-disable eqeqeq */\n            shouldRenderSuggestions != undefined && noOptionsText == undefined,\n            `When providing a shouldRenderSuggestions function, we recommend you also provide the noOptionsText prop and set it to a text explaining users why no options are displayed. It supports translation keys.`\n        );\n        /* eslint-enable eqeqeq */\n    }, [shouldRenderSuggestions, noOptionsText]);\n\n    const getRecordRepresentation = useGetRecordRepresentation(resource);\n\n    const { getChoiceText, getChoiceValue, getSuggestions } = useSuggestions({\n        choices: finalChoices,\n        limitChoicesToValue,\n        matchSuggestion,\n        optionText:\n            optionText ??\n            (isFromReference ? getRecordRepresentation : undefined),\n        optionValue,\n        selectedItem: selectedChoice,\n        suggestionLimit,\n        translateChoice: translateChoice ?? !isFromReference,\n    });\n\n    const [filterValue, setFilterValue] = useState('');\n\n    const handleChange = (newValue: any) => {\n        if (multiple) {\n            if (Array.isArray(newValue)) {\n                field.onChange(newValue.map(getChoiceValue), newValue);\n            } else {\n                field.onChange(\n                    [...(field.value ?? []), getChoiceValue(newValue)],\n                    newValue\n                );\n            }\n        } else {\n            field.onChange(getChoiceValue(newValue) ?? emptyValue, newValue);\n        }\n    };\n\n    // eslint-disable-next-line\n    const debouncedSetFilter = useCallback(\n        debounce(filter => {\n            if (setFilter) {\n                return setFilter(filter);\n            }\n\n            if (choicesProp) {\n                return;\n            }\n\n            setFilters(filterToQuery(filter));\n        }, debounceDelay),\n        [debounceDelay, setFilters, setFilter]\n    );\n\n    // We must reset the filter every time the value changes to ensure we\n    // display at least some choices even if the input has a value.\n    // Otherwise, it would only display the currently selected one and the user\n    // would have to first clear the input before seeing any other choices\n    const currentValue = useRef(field.value);\n    useEffect(() => {\n        if (!isEqual(currentValue.current, field.value)) {\n            currentValue.current = field.value;\n            debouncedSetFilter('');\n        }\n    }, [field.value]); // eslint-disable-line\n\n    const {\n        getCreateItem,\n        handleChange: handleChangeWithCreateSupport,\n        createElement,\n        createId,\n        getOptionDisabled: getOptionDisabledWithCreateSupport,\n    } = useSupportCreateSuggestion({\n        create,\n        createLabel,\n        createItemLabel,\n        createValue,\n        createHintValue,\n        handleChange,\n        filter: filterValue,\n        onCreate,\n        optionText,\n    });\n\n    const getOptionDisabled = useCallback(\n        option => {\n            return (\n                getOptionDisabledWithCreateSupport(option) ||\n                (getOptionDisabledProp && getOptionDisabledProp(option))\n            );\n        },\n        [getOptionDisabledProp, getOptionDisabledWithCreateSupport]\n    );\n\n    const getOptionLabel = useCallback(\n        (option: any, isListItem: boolean = false) => {\n            // eslint-disable-next-line eqeqeq\n            if (option == undefined) {\n                return '';\n            }\n\n            // Value selected with enter, right from the input\n            if (typeof option === 'string') {\n                return option;\n            }\n\n            if (option?.id === createId) {\n                return get(\n                    option,\n                    typeof optionText === 'string' ? optionText : 'name'\n                );\n            }\n\n            if (!isListItem && option[optionValue || 'id'] === emptyValue) {\n                return get(\n                    option,\n                    typeof optionText === 'string' ? optionText : 'name'\n                );\n            }\n\n            if (!isListItem && inputText !== undefined) {\n                return inputText(option);\n            }\n\n            return getChoiceText(option);\n        },\n        [\n            getChoiceText,\n            inputText,\n            createId,\n            optionText,\n            optionValue,\n            emptyValue,\n        ]\n    );\n\n    const finalOnBlur = useCallback((): void => {\n        if (clearOnBlur && !multiple) {\n            const optionLabel = getOptionLabel(selectedChoice);\n            if (!isEqual(optionLabel, filterValue)) {\n                setFilterValue(optionLabel);\n                debouncedSetFilter('');\n            }\n        }\n        field.onBlur();\n    }, [\n        clearOnBlur,\n        field,\n        getOptionLabel,\n        selectedChoice,\n        filterValue,\n        debouncedSetFilter,\n        multiple,\n    ]);\n\n    useEffect(() => {\n        if (!multiple) {\n            const optionLabel = getOptionLabel(selectedChoice);\n            if (typeof optionLabel === 'string') {\n                setFilterValue(optionLabel);\n            } else {\n                throw new Error(\n                    'When optionText returns a React element, you must also provide the inputText prop'\n                );\n            }\n        }\n    }, [getOptionLabel, multiple, selectedChoice]);\n\n    const handleInputChange: AutocompleteProps<\n        OptionType,\n        Multiple,\n        DisableClearable,\n        SupportCreate\n    >['onInputChange'] = (event, newInputValue, reason) => {\n        if (\n            event?.type === 'change' ||\n            !doesQueryMatchSelection(newInputValue)\n        ) {\n            const createOptionLabel = translate(createItemLabel, {\n                item: filterValue,\n                _: createItemLabel,\n            });\n            const isCreate = newInputValue === createOptionLabel;\n            const valueToSet = isCreate ? filterValue : newInputValue;\n            setFilterValue(valueToSet);\n            debouncedSetFilter(newInputValue);\n        }\n        if (reason === 'clear') {\n            setFilterValue('');\n            debouncedSetFilter('');\n        }\n        onInputChange?.(event, newInputValue, reason);\n    };\n\n    const doesQueryMatchSelection = useCallback(\n        (filter: string) => {\n            let selectedItemTexts;\n\n            if (multiple) {\n                selectedItemTexts = selectedChoice.map(item =>\n                    getOptionLabel(item)\n                );\n            } else {\n                selectedItemTexts = [getOptionLabel(selectedChoice)];\n            }\n\n            return selectedItemTexts.includes(filter);\n        },\n        [getOptionLabel, multiple, selectedChoice]\n    );\n    const doesQueryMatchSuggestion = useCallback(\n        filter => {\n            const hasOption = !!finalChoices\n                ? finalChoices.some(choice => getOptionLabel(choice) === filter)\n                : false;\n\n            return doesQueryMatchSelection(filter) || hasOption;\n        },\n        [finalChoices, getOptionLabel, doesQueryMatchSelection]\n    );\n\n    const filterOptions = (options, params) => {\n        let filteredOptions =\n            isFromReference || // When used inside a reference, AutocompleteInput shouldn't do the filtering as it's done by the reference input\n            matchSuggestion || // When using element as optionText (and matchSuggestion), options are filtered by getSuggestions, so they shouldn't be filtered here\n            limitChoicesToValue // When limiting choices to values (why? it's legacy!), options are also filtered by getSuggestions, so they shouldn't be filtered here\n                ? options\n                : defaultFilterOptions(options, params); // Otherwise, we let Material UI's Autocomplete do the filtering\n\n        // add create option if necessary\n        const { inputValue } = params;\n        if (onCreate || create) {\n            if (inputValue === '' && filterValue === '' && createLabel) {\n                // create option with createLabel\n                filteredOptions = filteredOptions.concat(getCreateItem(''));\n            } else if (\n                inputValue &&\n                filterValue &&\n                !doesQueryMatchSuggestion(filterValue)\n            ) {\n                filteredOptions = filteredOptions.concat(\n                    // create option with createItemLabel\n                    getCreateItem(inputValue)\n                );\n            }\n        }\n\n        return filteredOptions;\n    };\n\n    const handleAutocompleteChange = useCallback(\n        (event: any, newValue: any, reason: AutocompleteChangeReason) => {\n            // This prevents auto-submitting a form inside a dialog passed to the `create` prop\n            event.preventDefault();\n            if (reason === 'createOption') {\n                // When users press the enter key after typing a new value, we can handle it as if they clicked on the create option\n                handleChangeWithCreateSupport(getCreateItem(newValue));\n                return;\n            }\n            handleChangeWithCreateSupport(\n                newValue != null ? newValue : emptyValue\n            );\n        },\n        [emptyValue, getCreateItem, handleChangeWithCreateSupport]\n    );\n\n    const oneSecondHasPassed = useTimeout(1000, filterValue);\n\n    const suggestions = useMemo(() => {\n        if (!isFromReference && (matchSuggestion || limitChoicesToValue)) {\n            return getSuggestions(filterValue);\n        }\n        return finalChoices?.slice(0, suggestionLimit) || [];\n    }, [\n        finalChoices,\n        filterValue,\n        getSuggestions,\n        limitChoicesToValue,\n        matchSuggestion,\n        suggestionLimit,\n        isFromReference,\n    ]);\n\n    const isOptionEqualToValue = (option, value) => {\n        return String(getChoiceValue(option)) === String(getChoiceValue(value));\n    };\n    const renderHelperText = !!fetchError || helperText !== false || invalid;\n\n    return (\n        <>\n            <StyledAutocomplete\n                className={clsx('ra-input', `ra-input-${source}`, className)}\n                clearText={translate(clearText, { _: clearText })}\n                closeText={translate(closeText, { _: closeText })}\n                openOnFocus\n                openText={translate(openText, { _: openText })}\n                id={id}\n                isOptionEqualToValue={isOptionEqualToValue}\n                filterSelectedOptions\n                disabled={disabled || readOnly}\n                renderInput={params => {\n                    const mergedTextFieldProps = {\n                        readOnly,\n                        ...params.InputProps,\n                        ...TextFieldProps?.InputProps,\n                    };\n                    return (\n                        <TextField\n                            name={field.name}\n                            label={\n                                <FieldTitle\n                                    label={label}\n                                    source={source}\n                                    resource={resourceProp}\n                                    isRequired={isRequired}\n                                />\n                            }\n                            error={!!fetchError || invalid}\n                            helperText={\n                                renderHelperText ? (\n                                    <InputHelperText\n                                        error={\n                                            error?.message ||\n                                            fetchError?.message\n                                        }\n                                        helperText={helperText}\n                                    />\n                                ) : null\n                            }\n                            margin={margin}\n                            variant={variant}\n                            className={AutocompleteInputClasses.textField}\n                            {...params}\n                            {...TextFieldProps}\n                            InputProps={mergedTextFieldProps}\n                            size={size}\n                        />\n                    );\n                }}\n                multiple={multiple}\n                renderTags={(value, getTagProps) =>\n                    value.map((option, index) => {\n                        // We have to extract the key because react 19 does not allow to spread the key prop\n                        const { key, ...tagProps } = getTagProps({ index });\n                        return (\n                            <Chip\n                                label={\n                                    isValidElement(optionText)\n                                        ? inputText\n                                            ? inputText(option)\n                                            : ''\n                                        : getChoiceText(option)\n                                }\n                                size=\"small\"\n                                key={key}\n                                {...tagProps}\n                            />\n                        );\n                    })\n                }\n                noOptionsText={\n                    typeof noOptionsText === 'string'\n                        ? translate(noOptionsText, { _: noOptionsText })\n                        : noOptionsText\n                }\n                selectOnFocus\n                clearOnBlur={clearOnBlur}\n                {...sanitizeInputRestProps(rest)}\n                freeSolo={!!create || !!onCreate}\n                handleHomeEndKeys={!!create || !!onCreate}\n                filterOptions={filterOptions}\n                options={\n                    shouldRenderSuggestions == undefined || // eslint-disable-line eqeqeq\n                    shouldRenderSuggestions(filterValue)\n                        ? suggestions\n                        : []\n                }\n                getOptionLabel={getOptionLabel}\n                inputValue={filterValue}\n                loading={\n                    isPending &&\n                    (!finalChoices || finalChoices.length === 0) &&\n                    oneSecondHasPassed\n                }\n                value={selectedChoice}\n                onChange={handleAutocompleteChange}\n                onBlur={finalOnBlur}\n                onInputChange={handleInputChange}\n                renderOption={(props, record: RaRecord) => {\n                    // We have to extract the key because react 19 does not allow to spread the key prop\n                    const { key: ignoredKey, ...rest } = props;\n                    // We don't use MUI key which is generated from the option label because we may have options with the same label but with different values\n                    const key = getChoiceValue(record);\n                    const optionLabel = getOptionLabel(record, true);\n\n                    return (\n                        <li key={key} {...rest}>\n                            {optionLabel === '' ? ' ' : optionLabel}\n                        </li>\n                    );\n                }}\n                getOptionDisabled={getOptionDisabled}\n            />\n            {createElement}\n        </>\n    );\n};\n\nconst PREFIX = 'RaAutocompleteInput';\n\nexport const AutocompleteInputClasses = {\n    textField: `${PREFIX}-textField`,\n};\n\nconst StyledAutocomplete = styled(Autocomplete, {\n    name: PREFIX,\n    overridesResolver: (props, styles) => styles.root,\n})(({ theme }) => ({\n    [`& .${AutocompleteInputClasses.textField}`]: {\n        minWidth: theme.spacing(20),\n    },\n}));\n\n// @ts-ignore\nexport interface AutocompleteInputProps<\n    OptionType extends any = RaRecord,\n    Multiple extends boolean | undefined = false,\n    DisableClearable extends boolean | undefined = false,\n    SupportCreate extends boolean | undefined = false,\n> extends Omit<CommonInputProps, 'source' | 'onChange'>,\n        ChoicesProps,\n        UseSuggestionsOptions,\n        Omit<SupportCreateSuggestionOptions, 'handleChange' | 'optionText'>,\n        Omit<\n            AutocompleteProps<\n                OptionType,\n                Multiple,\n                DisableClearable,\n                SupportCreate\n            >,\n            'onChange' | 'options' | 'renderInput'\n        > {\n    children?: ReactNode;\n    debounce?: number;\n    emptyText?: string;\n    emptyValue?: any;\n    filterToQuery?: (searchText: string) => any;\n    inputText?: (option: any) => string;\n    onChange?: (\n        // We can't know upfront what the value type will be\n        value: Multiple extends true ? any[] : any,\n        // We return an empty string when the input is cleared in single mode\n        record: Multiple extends true ? OptionType[] : OptionType | ''\n    ) => void;\n    setFilter?: (value: string) => void;\n    shouldRenderSuggestions?: any;\n    // Source is optional as AutocompleteInput can be used inside a ReferenceInput that already defines the source\n    source?: string;\n    TextFieldProps?: TextFieldProps;\n}\n\n/**\n * Returns the selected choice (or choices if multiple) by matching the input value with the choices.\n */\nconst useSelectedChoice = <\n    OptionType extends any = RaRecord,\n    Multiple extends boolean | undefined = false,\n    DisableClearable extends boolean | undefined = false,\n    SupportCreate extends boolean | undefined = false,\n>(\n    value: any,\n    {\n        choices,\n        multiple,\n        optionValue,\n    }: AutocompleteInputProps<\n        OptionType,\n        Multiple,\n        DisableClearable,\n        SupportCreate\n    >\n) => {\n    const selectedChoiceRef = useRef(\n        getSelectedItems(choices, value, optionValue, multiple)\n    );\n    const [selectedChoice, setSelectedChoice] = useState<RaRecord | RaRecord[]>(\n        () => getSelectedItems(choices, value, optionValue, multiple)\n    );\n\n    // As the selected choices are objects, we want to ensure we pass the same\n    // reference to the Autocomplete as it would reset its filter value otherwise.\n    useEffect(() => {\n        const newSelectedItems = getSelectedItems(\n            choices,\n            value,\n            optionValue,\n            multiple\n        );\n\n        if (\n            !areSelectedItemsEqual(\n                selectedChoiceRef.current,\n                newSelectedItems,\n                optionValue,\n                multiple\n            )\n        ) {\n            selectedChoiceRef.current = newSelectedItems;\n            setSelectedChoice(newSelectedItems);\n        }\n    }, [choices, value, multiple, optionValue]);\n    return selectedChoice || null;\n};\n\nconst getSelectedItems = (\n    choices: RaRecord[] = [],\n    value,\n    optionValue = 'id',\n    multiple\n) => {\n    if (multiple) {\n        return (Array.isArray(value ?? []) ? value : [value])\n            .map(item =>\n                choices.find(\n                    choice => String(item) === String(get(choice, optionValue))\n                )\n            )\n            .filter(item => !!item);\n    }\n    return (\n        choices.find(\n            choice => String(get(choice, optionValue)) === String(value)\n        ) || ''\n    );\n};\n\nconst areSelectedItemsEqual = (\n    selectedChoice: RaRecord | RaRecord[],\n    newSelectedChoice: RaRecord | RaRecord[],\n    optionValue = 'id',\n    multiple?: boolean\n) => {\n    if (multiple) {\n        const selectedChoiceArray = (selectedChoice as RaRecord[]) ?? [];\n        const newSelectedChoiceArray = (newSelectedChoice as RaRecord[]) ?? [];\n        if (selectedChoiceArray.length !== newSelectedChoiceArray.length) {\n            return false;\n        }\n        const equalityArray = selectedChoiceArray.map(choice =>\n            newSelectedChoiceArray.some(\n                newChoice =>\n                    get(newChoice, optionValue) === get(choice, optionValue)\n            )\n        );\n        return !equalityArray.some(item => item === false);\n    }\n    return (\n        get(selectedChoice, optionValue) === get(newSelectedChoice, optionValue)\n    );\n};\n\nconst DefaultFilterToQuery = searchText => ({ q: searchText });\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}