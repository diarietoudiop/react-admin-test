{"ast":null,"code":"var __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport * as React from 'react';\nimport { useState, useCallback } from 'react';\nimport { AddUndoableMutationContext } from './AddUndoableMutationContext';\nimport { TakeUndoableMutationContext } from './TakeUndoableMutationContext';\n/**\n * Exposes and manages a queue of undoable mutations\n *\n * This context is used in CoreAdminContext so that every react-admin app\n * can use the useAddUndoableMutation and useTakeUndoableMutation hooks.\n *\n * Note: We need a separate queue for mutations (instead of using the\n * notifications queue) because the mutations are not dequeued when the\n * notification is displayed, but when it is dismissed.\n */\nexport var UndoableMutationsContextProvider = function (_a) {\n  var children = _a.children;\n  var _b = useState([]),\n    mutations = _b[0],\n    setMutations = _b[1];\n  /**\n   * Add a new mutation (pushes a new mutation to the queue).\n   *\n   * Used by optimistic data provider hooks, e.g., useDelete\n   */\n  var addMutation = useCallback(function (mutation) {\n    setMutations(function (mutations) {\n      return __spreadArray(__spreadArray([], mutations, true), [mutation], false);\n    });\n  }, []);\n  /**\n   * Get the next mutation to execute (shifts the first mutation from the queue) and returns it.\n   *\n   * Used by the Notification component to process or undo the mutation\n   */\n  var takeMutation = useCallback(function () {\n    if (mutations.length === 0) return;\n    var mutation = mutations[0],\n      rest = mutations.slice(1);\n    setMutations(rest);\n    return mutation;\n  }, [mutations]);\n  return React.createElement(TakeUndoableMutationContext.Provider, {\n    value: takeMutation\n  }, React.createElement(AddUndoableMutationContext.Provider, {\n    value: addMutation\n  }, children));\n};","map":{"version":3,"names":["React","useState","useCallback","AddUndoableMutationContext","TakeUndoableMutationContext","UndoableMutationsContextProvider","_a","children","_b","mutations","setMutations","addMutation","mutation","__spreadArray","takeMutation","length","rest","slice","createElement","Provider","value"],"sources":["/home/diarietou/Bureau/afterSA/test/testfront/react-admin-test/node_modules/ra-core/src/dataProvider/undo/UndoableMutationsContextProvider.tsx"],"sourcesContent":["import * as React from 'react';\nimport { useState, useCallback } from 'react';\n\nimport { AddUndoableMutationContext } from './AddUndoableMutationContext';\nimport { TakeUndoableMutationContext } from './TakeUndoableMutationContext';\nimport type { UndoableMutation } from './types';\n\n/**\n * Exposes and manages a queue of undoable mutations\n *\n * This context is used in CoreAdminContext so that every react-admin app\n * can use the useAddUndoableMutation and useTakeUndoableMutation hooks.\n *\n * Note: We need a separate queue for mutations (instead of using the\n * notifications queue) because the mutations are not dequeued when the\n * notification is displayed, but when it is dismissed.\n */\nexport const UndoableMutationsContextProvider = ({ children }) => {\n    const [mutations, setMutations] = useState<UndoableMutation[]>([]);\n\n    /**\n     * Add a new mutation (pushes a new mutation to the queue).\n     *\n     * Used by optimistic data provider hooks, e.g., useDelete\n     */\n    const addMutation = useCallback((mutation: UndoableMutation) => {\n        setMutations(mutations => [...mutations, mutation]);\n    }, []);\n\n    /**\n     * Get the next mutation to execute (shifts the first mutation from the queue) and returns it.\n     *\n     * Used by the Notification component to process or undo the mutation\n     */\n    const takeMutation = useCallback(() => {\n        if (mutations.length === 0) return;\n        const [mutation, ...rest] = mutations;\n        setMutations(rest);\n        return mutation;\n    }, [mutations]);\n\n    return (\n        <TakeUndoableMutationContext.Provider value={takeMutation}>\n            <AddUndoableMutationContext.Provider value={addMutation}>\n                {children}\n            </AddUndoableMutationContext.Provider>\n        </TakeUndoableMutationContext.Provider>\n    );\n};\n"],"mappings":";;;;;;;;;AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,SAASC,QAAQ,EAAEC,WAAW,QAAQ,OAAO;AAE7C,SAASC,0BAA0B,QAAQ,8BAA8B;AACzE,SAASC,2BAA2B,QAAQ,+BAA+B;AAG3E;;;;;;;;;;AAUA,OAAO,IAAMC,gCAAgC,GAAG,SAAAA,CAACC,EAAY;MAAVC,QAAQ,GAAAD,EAAA,CAAAC,QAAA;EACjD,IAAAC,EAAA,GAA4BP,QAAQ,CAAqB,EAAE,CAAC;IAA3DQ,SAAS,GAAAD,EAAA;IAAEE,YAAY,GAAAF,EAAA,GAAoC;EAElE;;;;;EAKA,IAAMG,WAAW,GAAGT,WAAW,CAAC,UAACU,QAA0B;IACvDF,YAAY,CAAC,UAAAD,SAAS;MAAI,OAAAI,aAAA,CAAAA,aAAA,KAAIJ,SAAS,UAAEG,QAAQ;IAAvB,CAAwB,CAAC;EACvD,CAAC,EAAE,EAAE,CAAC;EAEN;;;;;EAKA,IAAME,YAAY,GAAGZ,WAAW,CAAC;IAC7B,IAAIO,SAAS,CAACM,MAAM,KAAK,CAAC,EAAE;IACrB,IAAAH,QAAQ,GAAaH,SAAS,GAAtB;MAAKO,IAAI,GAAIP,SAAS,CAAAQ,KAAA,GAAb;IACxBP,YAAY,CAACM,IAAI,CAAC;IAClB,OAAOJ,QAAQ;EACnB,CAAC,EAAE,CAACH,SAAS,CAAC,CAAC;EAEf,OACIT,KAAA,CAAAkB,aAAA,CAACd,2BAA2B,CAACe,QAAQ;IAACC,KAAK,EAAEN;EAAY,GACrDd,KAAA,CAAAkB,aAAA,CAACf,0BAA0B,CAACgB,QAAQ;IAACC,KAAK,EAAET;EAAW,GAClDJ,QAAQ,CACyB,CACH;AAE/C,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}