{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (g && (g = 0, op[0] && (_ = 0)), _) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nimport { useCallback } from 'react';\nimport { useResourceContext } from '../core/useResourceContext';\nimport { useResourceDefinitions } from '../core/useResourceDefinitions';\nimport { useCanAccessCallback } from '../auth/useCanAccessCallback';\nimport { useCreatePath } from './useCreatePath';\nexport var useGetPathForRecordCallback = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var resource = useResourceContext(options);\n  var resourceDefinitions = useResourceDefinitions();\n  var createPath = useCreatePath();\n  var canAccess = useCanAccessCallback();\n  return useCallback(function (params) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var _a, link, record, finalResource, resourceDefinition, _b, canAccessShow, canAccessEdit, linkFunc, linkResult, linkResultIsPromise, resolvedLink;\n      var _c, _d;\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            _a = params || {}, link = _a.link, record = _a.record;\n            finalResource = (_c = params.resource) !== null && _c !== void 0 ? _c : resource;\n            if (!finalResource) {\n              throw new Error('Cannot generate a link for a record without a resource. You must use useGetPathForRecordCallback within a ResourceContextProvider, or pass a resource parameter.');\n            }\n            resourceDefinition = (_d = resourceDefinitions[finalResource]) !== null && _d !== void 0 ? _d : {};\n            if (record == null || link === false) {\n              return [2 /*return*/, false];\n            }\n            if (!(link == null)) return [3 /*break*/, 2];\n            return [4 /*yield*/, Promise.all([resourceDefinition.hasShow ? canAccess({\n              action: 'show',\n              resource: finalResource,\n              record: record\n            }) : Promise.resolve(false), resourceDefinition.hasEdit ? canAccess({\n              action: 'edit',\n              resource: finalResource,\n              record: record\n            }) : Promise.resolve(false)])];\n          case 1:\n            _b = _e.sent(), canAccessShow = _b[0], canAccessEdit = _b[1];\n            if (canAccessShow) {\n              return [2 /*return*/, createPath({\n                resource: finalResource,\n                id: record.id,\n                type: 'show'\n              })];\n            }\n            if (canAccessEdit) {\n              return [2 /*return*/, createPath({\n                resource: finalResource,\n                id: record.id,\n                type: 'edit'\n              })];\n            }\n            return [2 /*return*/, false];\n          case 2:\n            linkFunc = typeof link === 'function' ? link : function () {\n              return link;\n            };\n            linkResult = linkFunc(record, finalResource);\n            if (linkResult === false) {\n              return [2 /*return*/, false];\n            }\n            linkResultIsPromise = isPromise(linkResult);\n            if (!linkResultIsPromise) return [3 /*break*/, 4];\n            return [4 /*yield*/, linkResult];\n          case 3:\n            resolvedLink = _e.sent();\n            if (resolvedLink === false) {\n              // already set to false by default\n              return [2 /*return*/];\n            }\n            return [2 /*return*/, createPath({\n              resource: finalResource,\n              id: record.id,\n              type: resolvedLink\n            })];\n          case 4:\n            return [2 /*return*/, createPath({\n              resource: finalResource,\n              id: record.id,\n              type: linkResult\n            })];\n        }\n      });\n    });\n  }, [canAccess, createPath, resourceDefinitions, resource]);\n};\nvar isPromise = function (value) {\n  return value && typeof value.then === 'function';\n};","map":{"version":3,"names":["useCallback","useResourceContext","useResourceDefinitions","useCanAccessCallback","useCreatePath","useGetPathForRecordCallback","options","resource","resourceDefinitions","createPath","canAccess","params","__awaiter","_a","link","record","finalResource","_c","Error","resourceDefinition","_d","Promise","all","hasShow","action","resolve","hasEdit","_b","_e","sent","canAccessShow","canAccessEdit","id","type","linkFunc","linkResult","linkResultIsPromise","isPromise","resolvedLink","value","then"],"sources":["/home/diarietou/Bureau/afterSA/test/testfront/react-admin-test/node_modules/ra-core/src/routing/useGetPathForRecordCallback.ts"],"sourcesContent":["import { useCallback } from 'react';\nimport { useResourceContext } from '../core/useResourceContext';\nimport { useResourceDefinitions } from '../core/useResourceDefinitions';\nimport { useCanAccessCallback } from '../auth/useCanAccessCallback';\nimport type { RaRecord } from '../types';\nimport { useCreatePath } from './useCreatePath';\nimport { UseGetRouteForRecordOptions } from './useGetPathForRecord';\n\nexport const useGetPathForRecordCallback = <\n    RecordType extends RaRecord = RaRecord,\n>(\n    options: UseGetPathForRecordCallbackOptions = {}\n) => {\n    const resource = useResourceContext(options);\n    const resourceDefinitions = useResourceDefinitions();\n    const createPath = useCreatePath();\n    const canAccess = useCanAccessCallback();\n\n    return useCallback(\n        async (params: UseGetRouteForRecordOptions<RecordType>) => {\n            const { link, record } = params || {};\n            const finalResource = params.resource ?? resource;\n            if (!finalResource) {\n                throw new Error(\n                    'Cannot generate a link for a record without a resource. You must use useGetPathForRecordCallback within a ResourceContextProvider, or pass a resource parameter.'\n                );\n            }\n            const resourceDefinition = resourceDefinitions[finalResource] ?? {};\n\n            if (record == null || link === false) {\n                return false;\n            }\n\n            // When the link prop is not provided, we infer a default value and check whether users\n            // can access it\n            if (link == null) {\n                // check if the user can access the show and edit pages in parallel\n                const [canAccessShow, canAccessEdit] = await Promise.all([\n                    resourceDefinition.hasShow\n                        ? canAccess({\n                              action: 'show',\n                              resource: finalResource,\n                              record,\n                          })\n                        : Promise.resolve(false),\n                    resourceDefinition.hasEdit\n                        ? canAccess({\n                              action: 'edit',\n                              resource: finalResource,\n                              record,\n                          })\n                        : Promise.resolve(false),\n                ]);\n\n                if (canAccessShow) {\n                    return createPath({\n                        resource: finalResource,\n                        id: record.id,\n                        type: 'show',\n                    });\n                }\n                if (canAccessEdit) {\n                    return createPath({\n                        resource: finalResource,\n                        id: record.id,\n                        type: 'edit',\n                    });\n                }\n                return false;\n            }\n\n            const linkFunc = typeof link === 'function' ? link : () => link;\n            const linkResult = linkFunc(record, finalResource);\n            if (linkResult === false) {\n                return false;\n            }\n\n            const linkResultIsPromise = isPromise(linkResult);\n\n            if (linkResultIsPromise) {\n                const resolvedLink = await linkResult;\n                if (resolvedLink === false) {\n                    // already set to false by default\n                    return;\n                }\n                return createPath({\n                    resource: finalResource,\n                    id: record.id,\n                    type: resolvedLink,\n                });\n            }\n\n            return createPath({\n                resource: finalResource,\n                id: record.id,\n                type: linkResult,\n            });\n        },\n        [canAccess, createPath, resourceDefinitions, resource]\n    );\n};\n\nconst isPromise = (value: any): value is Promise<any> =>\n    value && typeof value.then === 'function';\n\nexport interface UseGetPathForRecordCallbackOptions {\n    resource?: string;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAASA,WAAW,QAAQ,OAAO;AACnC,SAASC,kBAAkB,QAAQ,4BAA4B;AAC/D,SAASC,sBAAsB,QAAQ,gCAAgC;AACvE,SAASC,oBAAoB,QAAQ,8BAA8B;AAEnE,SAASC,aAAa,QAAQ,iBAAiB;AAG/C,OAAO,IAAMC,2BAA2B,GAAG,SAAAA,CAGvCC,OAAgD;EAAhD,IAAAA,OAAA;IAAAA,OAAA,KAAgD;EAAA;EAEhD,IAAMC,QAAQ,GAAGN,kBAAkB,CAACK,OAAO,CAAC;EAC5C,IAAME,mBAAmB,GAAGN,sBAAsB,EAAE;EACpD,IAAMO,UAAU,GAAGL,aAAa,EAAE;EAClC,IAAMM,SAAS,GAAGP,oBAAoB,EAAE;EAExC,OAAOH,WAAW,CACd,UAAOW,MAA+C;IAAA,OAAAC,SAAA;;;;;;YAC5CC,EAAA,GAAmBF,MAAM,IAAI,EAAE,EAA7BG,IAAI,GAAAD,EAAA,CAAAC,IAAA,EAAEC,MAAM,GAAAF,EAAA,CAAAE,MAAA;YACdC,aAAa,GAAG,CAAAC,EAAA,GAAAN,MAAM,CAACJ,QAAQ,cAAAU,EAAA,cAAAA,EAAA,GAAIV,QAAQ;YACjD,IAAI,CAACS,aAAa,EAAE;cAChB,MAAM,IAAIE,KAAK,CACX,kKAAkK,CACrK;;YAECC,kBAAkB,GAAG,CAAAC,EAAA,GAAAZ,mBAAmB,CAACQ,aAAa,CAAC,cAAAI,EAAA,cAAAA,EAAA,GAAI,EAAE;YAEnE,IAAIL,MAAM,IAAI,IAAI,IAAID,IAAI,KAAK,KAAK,EAAE;cAClC,sBAAO,KAAK;;kBAKZA,IAAI,IAAI,IAAI,GAAZ;YAEuC,qBAAMO,OAAO,CAACC,GAAG,CAAC,CACrDH,kBAAkB,CAACI,OAAO,GACpBb,SAAS,CAAC;cACNc,MAAM,EAAE,MAAM;cACdjB,QAAQ,EAAES,aAAa;cACvBD,MAAM,EAAAA;aACT,CAAC,GACFM,OAAO,CAACI,OAAO,CAAC,KAAK,CAAC,EAC5BN,kBAAkB,CAACO,OAAO,GACpBhB,SAAS,CAAC;cACNc,MAAM,EAAE,MAAM;cACdjB,QAAQ,EAAES,aAAa;cACvBD,MAAM,EAAAA;aACT,CAAC,GACFM,OAAO,CAACI,OAAO,CAAC,KAAK,CAAC,CAC/B,CAAC;;YAfIE,EAAA,GAAiCC,EAAA,CAAAC,IAAA,EAerC,EAfKC,aAAa,GAAAH,EAAA,KAAEI,aAAa,GAAAJ,EAAA;YAiBnC,IAAIG,aAAa,EAAE;cACf,sBAAOrB,UAAU,CAAC;gBACdF,QAAQ,EAAES,aAAa;gBACvBgB,EAAE,EAAEjB,MAAM,CAACiB,EAAE;gBACbC,IAAI,EAAE;eACT,CAAC;;YAEN,IAAIF,aAAa,EAAE;cACf,sBAAOtB,UAAU,CAAC;gBACdF,QAAQ,EAAES,aAAa;gBACvBgB,EAAE,EAAEjB,MAAM,CAACiB,EAAE;gBACbC,IAAI,EAAE;eACT,CAAC;;YAEN,sBAAO,KAAK;;YAGVC,QAAQ,GAAG,OAAOpB,IAAI,KAAK,UAAU,GAAGA,IAAI,GAAG;cAAM,OAAAA,IAAI;YAAJ,CAAI;YACzDqB,UAAU,GAAGD,QAAQ,CAACnB,MAAM,EAAEC,aAAa,CAAC;YAClD,IAAImB,UAAU,KAAK,KAAK,EAAE;cACtB,sBAAO,KAAK;;YAGVC,mBAAmB,GAAGC,SAAS,CAACF,UAAU,CAAC;iBAE7CC,mBAAmB,EAAnB;YACqB,qBAAMD,UAAU;;YAA/BG,YAAY,GAAGV,EAAA,CAAAC,IAAA,EAAgB;YACrC,IAAIS,YAAY,KAAK,KAAK,EAAE;cACxB;cACA;;YAEJ,sBAAO7B,UAAU,CAAC;cACdF,QAAQ,EAAES,aAAa;cACvBgB,EAAE,EAAEjB,MAAM,CAACiB,EAAE;cACbC,IAAI,EAAEK;aACT,CAAC;;YAGN,sBAAO7B,UAAU,CAAC;cACdF,QAAQ,EAAES,aAAa;cACvBgB,EAAE,EAAEjB,MAAM,CAACiB,EAAE;cACbC,IAAI,EAAEE;aACT,CAAC;;;;GACL,EACD,CAACzB,SAAS,EAAED,UAAU,EAAED,mBAAmB,EAAED,QAAQ,CAAC,CACzD;AACL,CAAC;AAED,IAAM8B,SAAS,GAAG,SAAAA,CAACE,KAAU;EACzB,OAAAA,KAAK,IAAI,OAAOA,KAAK,CAACC,IAAI,KAAK,UAAU;AAAzC,CAAyC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}