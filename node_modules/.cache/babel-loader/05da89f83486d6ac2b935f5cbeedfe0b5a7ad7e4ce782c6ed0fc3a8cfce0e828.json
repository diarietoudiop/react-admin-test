{"ast":null,"code":"import { useEffect, useRef, useState } from 'react';\nimport { parse } from 'query-string';\nimport { useLocation } from 'react-router-dom';\nimport isEqual from 'lodash/isEqual';\n/**\n * A hook that returns the record to use to override the values in a form\n * @param options The hook options\n * @param options.searchSource The key in the location search to use as a source for the record. Its content should be a stringified JSON object.\n * @param options.stateSource The key in the location state to use as a source for the record\n * @returns The record to use to override the values in a form\n */\nexport var useRecordFromLocation = function (props) {\n  if (props === void 0) {\n    props = {};\n  }\n  var searchSource = props.searchSource,\n    stateSource = props.stateSource;\n  var location = useLocation();\n  var _a = useState(function () {\n      return getRecordFromLocation(location, {\n        stateSource: stateSource,\n        searchSource: searchSource\n      });\n    }),\n    recordFromLocation = _a[0],\n    setRecordFromLocation = _a[1];\n  // To avoid having the form resets when the location changes but the final record is the same\n  // This is needed for forms such as TabbedForm or WizardForm that may change the location for their sections\n  var previousRecordRef = useRef(recordFromLocation);\n  useEffect(function () {\n    var newRecordFromLocation = getRecordFromLocation(location, {\n      stateSource: stateSource,\n      searchSource: searchSource\n    });\n    if (!isEqual(newRecordFromLocation, previousRecordRef.current)) {\n      previousRecordRef.current = newRecordFromLocation;\n      setRecordFromLocation(newRecordFromLocation);\n    }\n  }, [location, stateSource, searchSource]);\n  return recordFromLocation;\n};\n/**\n * Get the initial record from the location, whether it comes from the location\n * state or is serialized in the url search part.\n */\nexport var getRecordFromLocation = function (_a, _b) {\n  var state = _a.state,\n    search = _a.search;\n  var _c = _b === void 0 ? {} : _b,\n    _d = _c.searchSource,\n    searchSource = _d === void 0 ? 'source' : _d,\n    _e = _c.stateSource,\n    stateSource = _e === void 0 ? 'record' : _e;\n  if (state && state[stateSource]) {\n    return state[stateSource];\n  }\n  if (search) {\n    try {\n      var searchParams = parse(search);\n      var source = searchParams[searchSource];\n      if (source) {\n        if (Array.isArray(source)) {\n          console.error(\"Failed to parse location \".concat(searchSource, \" parameter '\").concat(search, \"'. To pre-fill some fields in the Create form, pass a stringified \").concat(searchSource, \" parameter (e.g. '?\").concat(searchSource, \"={\\\"title\\\":\\\"foo\\\"}')\"));\n          return null;\n        }\n        return JSON.parse(source);\n      }\n    } catch (e) {\n      console.error(\"Failed to parse location \".concat(searchSource, \" parameter '\").concat(search, \"'. To pre-fill some fields in the Create form, pass a stringified \").concat(searchSource, \" parameter (e.g. '?\").concat(searchSource, \"={\\\"title\\\":\\\"foo\\\"}')\"));\n    }\n  }\n  return null;\n};","map":{"version":3,"names":["useEffect","useRef","useState","parse","useLocation","isEqual","useRecordFromLocation","props","searchSource","stateSource","location","_a","getRecordFromLocation","recordFromLocation","setRecordFromLocation","previousRecordRef","newRecordFromLocation","current","_b","state","search","_c","_d","_e","searchParams","source","Array","isArray","console","error","concat","JSON","e"],"sources":["/home/diarietou/Bureau/afterSA/test/testfront/react-admin-test/node_modules/ra-core/src/form/useRecordFromLocation.ts"],"sourcesContent":["import { useEffect, useRef, useState } from 'react';\nimport { parse } from 'query-string';\nimport { Location, useLocation } from 'react-router-dom';\nimport isEqual from 'lodash/isEqual';\nimport { RaRecord } from '../types';\n\n/**\n * A hook that returns the record to use to override the values in a form\n * @param options The hook options\n * @param options.searchSource The key in the location search to use as a source for the record. Its content should be a stringified JSON object.\n * @param options.stateSource The key in the location state to use as a source for the record\n * @returns The record to use to override the values in a form\n */\nexport const useRecordFromLocation = (\n    props: UseRecordFromLocationOptions = {}\n) => {\n    const { searchSource, stateSource } = props;\n    const location = useLocation();\n    const [recordFromLocation, setRecordFromLocation] = useState(() =>\n        getRecordFromLocation(location, {\n            stateSource,\n            searchSource,\n        })\n    );\n\n    // To avoid having the form resets when the location changes but the final record is the same\n    // This is needed for forms such as TabbedForm or WizardForm that may change the location for their sections\n    const previousRecordRef = useRef(recordFromLocation);\n\n    useEffect(() => {\n        const newRecordFromLocation = getRecordFromLocation(location, {\n            stateSource,\n            searchSource,\n        });\n\n        if (!isEqual(newRecordFromLocation, previousRecordRef.current)) {\n            previousRecordRef.current = newRecordFromLocation;\n            setRecordFromLocation(newRecordFromLocation);\n        }\n    }, [location, stateSource, searchSource]);\n\n    return recordFromLocation;\n};\n\nexport type UseRecordFromLocationOptions = {\n    searchSource?: string;\n    stateSource?: string;\n};\n\n/**\n * Get the initial record from the location, whether it comes from the location\n * state or is serialized in the url search part.\n */\nexport const getRecordFromLocation = (\n    { state, search }: Location,\n    {\n        searchSource = 'source',\n        stateSource = 'record',\n    }: {\n        searchSource?: string;\n        stateSource?: string;\n    } = {}\n): Partial<RaRecord> | null => {\n    if (state && state[stateSource]) {\n        return state[stateSource];\n    }\n    if (search) {\n        try {\n            const searchParams = parse(search);\n            const source = searchParams[searchSource];\n            if (source) {\n                if (Array.isArray(source)) {\n                    console.error(\n                        `Failed to parse location ${searchSource} parameter '${search}'. To pre-fill some fields in the Create form, pass a stringified ${searchSource} parameter (e.g. '?${searchSource}={\"title\":\"foo\"}')`\n                    );\n                    return null;\n                }\n                return JSON.parse(source);\n            }\n        } catch (e) {\n            console.error(\n                `Failed to parse location ${searchSource} parameter '${search}'. To pre-fill some fields in the Create form, pass a stringified ${searchSource} parameter (e.g. '?${searchSource}={\"title\":\"foo\"}')`\n            );\n        }\n    }\n    return null;\n};\n"],"mappings":"AAAA,SAASA,SAAS,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AACnD,SAASC,KAAK,QAAQ,cAAc;AACpC,SAAmBC,WAAW,QAAQ,kBAAkB;AACxD,OAAOC,OAAO,MAAM,gBAAgB;AAGpC;;;;;;;AAOA,OAAO,IAAMC,qBAAqB,GAAG,SAAAA,CACjCC,KAAwC;EAAxC,IAAAA,KAAA;IAAAA,KAAA,KAAwC;EAAA;EAEhC,IAAAC,YAAY,GAAkBD,KAAK,CAAAC,YAAvB;IAAEC,WAAW,GAAKF,KAAK,CAAAE,WAAV;EACjC,IAAMC,QAAQ,GAAGN,WAAW,EAAE;EACxB,IAAAO,EAAA,GAA8CT,QAAQ,CAAC;MACzD,OAAAU,qBAAqB,CAACF,QAAQ,EAAE;QAC5BD,WAAW,EAAAA,WAAA;QACXD,YAAY,EAAAA;OACf,CAAC;IAHF,CAGE,CACL;IALMK,kBAAkB,GAAAF,EAAA;IAAEG,qBAAqB,GAAAH,EAAA,GAK/C;EAED;EACA;EACA,IAAMI,iBAAiB,GAAGd,MAAM,CAACY,kBAAkB,CAAC;EAEpDb,SAAS,CAAC;IACN,IAAMgB,qBAAqB,GAAGJ,qBAAqB,CAACF,QAAQ,EAAE;MAC1DD,WAAW,EAAAA,WAAA;MACXD,YAAY,EAAAA;KACf,CAAC;IAEF,IAAI,CAACH,OAAO,CAACW,qBAAqB,EAAED,iBAAiB,CAACE,OAAO,CAAC,EAAE;MAC5DF,iBAAiB,CAACE,OAAO,GAAGD,qBAAqB;MACjDF,qBAAqB,CAACE,qBAAqB,CAAC;;EAEpD,CAAC,EAAE,CAACN,QAAQ,EAAED,WAAW,EAAED,YAAY,CAAC,CAAC;EAEzC,OAAOK,kBAAkB;AAC7B,CAAC;AAOD;;;;AAIA,OAAO,IAAMD,qBAAqB,GAAG,SAAAA,CACjCD,EAA2B,EAC3BO,EAMM;MAPJC,KAAK,GAAAR,EAAA,CAAAQ,KAAA;IAAEC,MAAM,GAAAT,EAAA,CAAAS,MAAA;MACfC,EAAA,GAAAH,EAAA,cAMI,EAAE,GAAAA,EAAA;IALFI,EAAA,GAAAD,EAAA,CAAAb,YAAuB;IAAvBA,YAAY,GAAAc,EAAA,cAAG,QAAQ,GAAAA,EAAA;IACvBC,EAAA,GAAAF,EAAA,CAAAZ,WAAsB;IAAtBA,WAAW,GAAAc,EAAA,cAAG,QAAQ,GAAAA,EAAA;EAM1B,IAAIJ,KAAK,IAAIA,KAAK,CAACV,WAAW,CAAC,EAAE;IAC7B,OAAOU,KAAK,CAACV,WAAW,CAAC;;EAE7B,IAAIW,MAAM,EAAE;IACR,IAAI;MACA,IAAMI,YAAY,GAAGrB,KAAK,CAACiB,MAAM,CAAC;MAClC,IAAMK,MAAM,GAAGD,YAAY,CAAChB,YAAY,CAAC;MACzC,IAAIiB,MAAM,EAAE;QACR,IAAIC,KAAK,CAACC,OAAO,CAACF,MAAM,CAAC,EAAE;UACvBG,OAAO,CAACC,KAAK,CACT,4BAAAC,MAAA,CAA4BtB,YAAY,kBAAAsB,MAAA,CAAeV,MAAM,wEAAAU,MAAA,CAAqEtB,YAAY,yBAAAsB,MAAA,CAAsBtB,YAAY,2BAAoB,CACvM;UACD,OAAO,IAAI;;QAEf,OAAOuB,IAAI,CAAC5B,KAAK,CAACsB,MAAM,CAAC;;KAEhC,CAAC,OAAOO,CAAC,EAAE;MACRJ,OAAO,CAACC,KAAK,CACT,4BAAAC,MAAA,CAA4BtB,YAAY,kBAAAsB,MAAA,CAAeV,MAAM,wEAAAU,MAAA,CAAqEtB,YAAY,yBAAAsB,MAAA,CAAsBtB,YAAY,2BAAoB,CACvM;;;EAGT,OAAO,IAAI;AACf,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}